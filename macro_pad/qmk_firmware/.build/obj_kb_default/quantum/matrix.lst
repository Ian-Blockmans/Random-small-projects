   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_scan_user,"ax",@progbits
  11               		.weak	matrix_scan_user
  13               	matrix_scan_user:
  14               	.LFB11:
  15               		.file 1 "quantum/matrix.c"
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012 Jun Wako
   3:quantum/matrix.c **** Copyright 2014 Jack Humbert
   4:quantum/matrix.c **** 
   5:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   6:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   7:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   8:quantum/matrix.c **** (at your option) any later version.
   9:quantum/matrix.c **** 
  10:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  11:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  12:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13:quantum/matrix.c **** GNU General Public License for more details.
  14:quantum/matrix.c **** 
  15:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  16:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  17:quantum/matrix.c **** */
  18:quantum/matrix.c **** #include <stdint.h>
  19:quantum/matrix.c **** #include <stdbool.h>
  20:quantum/matrix.c **** #if defined(__AVR__)
  21:quantum/matrix.c **** #include <avr/io.h>
  22:quantum/matrix.c **** #endif
  23:quantum/matrix.c **** #include "wait.h"
  24:quantum/matrix.c **** #include "print.h"
  25:quantum/matrix.c **** #include "debug.h"
  26:quantum/matrix.c **** #include "util.h"
  27:quantum/matrix.c **** #include "matrix.h"
  28:quantum/matrix.c **** #include "timer.h"
  29:quantum/matrix.c **** 
  30:quantum/matrix.c **** 
  31:quantum/matrix.c **** /* Set 0 if debouncing isn't needed */
  32:quantum/matrix.c **** 
  33:quantum/matrix.c **** #ifndef DEBOUNCING_DELAY
  34:quantum/matrix.c **** #   define DEBOUNCING_DELAY 5
  35:quantum/matrix.c **** #endif
  36:quantum/matrix.c **** 
  37:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
  38:quantum/matrix.c ****     static uint16_t debouncing_time;
  39:quantum/matrix.c ****     static bool debouncing = false;
  40:quantum/matrix.c **** #endif
  41:quantum/matrix.c **** 
  42:quantum/matrix.c **** #if (MATRIX_COLS <= 8)
  43:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 01234567\n")
  44:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse8(matrix_get_row(row))
  45:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop(matrix[i])
  46:quantum/matrix.c **** #    define ROW_SHIFTER ((uint8_t)1)
  47:quantum/matrix.c **** #elif (MATRIX_COLS <= 16)
  48:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF\n")
  49:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse16(matrix_get_row(row))
  50:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop16(matrix[i])
  51:quantum/matrix.c **** #    define ROW_SHIFTER ((uint16_t)1)
  52:quantum/matrix.c **** #elif (MATRIX_COLS <= 32)
  53:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF0123456789ABCDEF\n")
  54:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse32(matrix_get_row(row))
  55:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop32(matrix[i])
  56:quantum/matrix.c **** #    define ROW_SHIFTER  ((uint32_t)1)
  57:quantum/matrix.c **** #endif
  58:quantum/matrix.c **** 
  59:quantum/matrix.c **** #ifdef MATRIX_MASKED
  60:quantum/matrix.c ****     extern const matrix_row_t matrix_mask[];
  61:quantum/matrix.c **** #endif
  62:quantum/matrix.c **** 
  63:quantum/matrix.c **** static const uint8_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  64:quantum/matrix.c **** static const uint8_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  65:quantum/matrix.c **** 
  66:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  67:quantum/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  68:quantum/matrix.c **** 
  69:quantum/matrix.c **** static matrix_row_t matrix_raw[MATRIX_ROWS];
  70:quantum/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  71:quantum/matrix.c **** 
  72:quantum/matrix.c **** 
  73:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
  74:quantum/matrix.c ****     static void init_cols(void);
  75:quantum/matrix.c ****     static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row);
  76:quantum/matrix.c ****     static void unselect_rows(void);
  77:quantum/matrix.c ****     static void select_row(uint8_t row);
  78:quantum/matrix.c ****     static void unselect_row(uint8_t row);
  79:quantum/matrix.c **** #else // ROW2COL
  80:quantum/matrix.c ****     static void init_rows(void);
  81:quantum/matrix.c ****     static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col);
  82:quantum/matrix.c ****     static void unselect_cols(void);
  83:quantum/matrix.c ****     static void unselect_col(uint8_t col);
  84:quantum/matrix.c ****     static void select_col(uint8_t col);
  85:quantum/matrix.c **** #endif
  86:quantum/matrix.c **** 
  87:quantum/matrix.c **** __attribute__ ((weak))
  88:quantum/matrix.c **** void matrix_init_quantum(void) {
  89:quantum/matrix.c ****     matrix_init_kb();
  90:quantum/matrix.c **** }
  91:quantum/matrix.c **** 
  92:quantum/matrix.c **** __attribute__ ((weak))
  93:quantum/matrix.c **** void matrix_scan_quantum(void) {
  94:quantum/matrix.c ****     matrix_scan_kb();
  95:quantum/matrix.c **** }
  96:quantum/matrix.c **** 
  97:quantum/matrix.c **** __attribute__ ((weak))
  98:quantum/matrix.c **** void matrix_init_kb(void) {
  99:quantum/matrix.c ****     matrix_init_user();
 100:quantum/matrix.c **** }
 101:quantum/matrix.c **** 
 102:quantum/matrix.c **** __attribute__ ((weak))
 103:quantum/matrix.c **** void matrix_scan_kb(void) {
 104:quantum/matrix.c ****     matrix_scan_user();
 105:quantum/matrix.c **** }
 106:quantum/matrix.c **** 
 107:quantum/matrix.c **** __attribute__ ((weak))
 108:quantum/matrix.c **** void matrix_init_user(void) {
 109:quantum/matrix.c **** }
 110:quantum/matrix.c **** 
 111:quantum/matrix.c **** __attribute__ ((weak))
 112:quantum/matrix.c **** void matrix_scan_user(void) {
  16               		.loc 1 112 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22 0000 0895      		ret
  23               		.cfi_endproc
  24               	.LFE11:
  26               		.set	matrix_scan_user.localalias.0,matrix_scan_user
  27               		.section	.text.matrix_init_user,"ax",@progbits
  28               		.weak	matrix_init_user
  30               	matrix_init_user:
  31               	.LFB29:
  32               		.cfi_startproc
  33               	/* prologue: function */
  34               	/* frame size = 0 */
  35               	/* stack size = 0 */
  36               	.L__stack_usage = 0
  37 0000 0C94 0000 		jmp matrix_scan_user.localalias.0
  38               		.cfi_endproc
  39               	.LFE29:
  41               		.section	.text.matrix_init_kb,"ax",@progbits
  42               		.weak	matrix_init_kb
  44               	matrix_init_kb:
  45               	.LFB8:
  98:quantum/matrix.c ****     matrix_init_user();
  46               		.loc 1 98 0
  47               		.cfi_startproc
  48               	/* prologue: function */
  49               	/* frame size = 0 */
  50               	/* stack size = 0 */
  51               	.L__stack_usage = 0
  99:quantum/matrix.c **** }
  52               		.loc 1 99 0
  53 0000 0C94 0000 		jmp matrix_init_user
  54               	.LVL0:
  55               		.cfi_endproc
  56               	.LFE8:
  58               		.section	.text.matrix_init_quantum,"ax",@progbits
  59               		.weak	matrix_init_quantum
  61               	matrix_init_quantum:
  62               	.LFB6:
  88:quantum/matrix.c ****     matrix_init_kb();
  63               		.loc 1 88 0
  64               		.cfi_startproc
  65               	/* prologue: function */
  66               	/* frame size = 0 */
  67               	/* stack size = 0 */
  68               	.L__stack_usage = 0
  89:quantum/matrix.c **** }
  69               		.loc 1 89 0
  70 0000 0C94 0000 		jmp matrix_init_kb
  71               	.LVL1:
  72               		.cfi_endproc
  73               	.LFE6:
  75               		.section	.text.matrix_scan_kb,"ax",@progbits
  76               		.weak	matrix_scan_kb
  78               	matrix_scan_kb:
  79               	.LFB9:
 103:quantum/matrix.c ****     matrix_scan_user();
  80               		.loc 1 103 0
  81               		.cfi_startproc
  82               	/* prologue: function */
  83               	/* frame size = 0 */
  84               	/* stack size = 0 */
  85               	.L__stack_usage = 0
 104:quantum/matrix.c **** }
  86               		.loc 1 104 0
  87 0000 0C94 0000 		jmp matrix_scan_user
  88               	.LVL2:
  89               		.cfi_endproc
  90               	.LFE9:
  92               		.section	.text.matrix_scan_quantum,"ax",@progbits
  93               		.weak	matrix_scan_quantum
  95               	matrix_scan_quantum:
  96               	.LFB7:
  93:quantum/matrix.c ****     matrix_scan_kb();
  97               		.loc 1 93 0
  98               		.cfi_startproc
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
  94:quantum/matrix.c **** }
 103               		.loc 1 94 0
 104 0000 0C94 0000 		jmp matrix_scan_kb
 105               	.LVL3:
 106               		.cfi_endproc
 107               	.LFE7:
 109               		.section	.text.matrix_rows,"ax",@progbits
 110               	.global	matrix_rows
 112               	matrix_rows:
 113               	.LFB27:
 114               		.cfi_startproc
 115               	/* prologue: function */
 116               	/* frame size = 0 */
 117               	/* stack size = 0 */
 118               	.L__stack_usage = 0
 119 0000 84E0      		ldi r24,lo8(4)
 120 0002 0895      		ret
 121               		.cfi_endproc
 122               	.LFE27:
 124               		.section	.text.matrix_cols,"ax",@progbits
 125               	.global	matrix_cols
 127               	matrix_cols:
 128               	.LFB13:
 113:quantum/matrix.c **** }
 114:quantum/matrix.c **** 
 115:quantum/matrix.c **** inline
 116:quantum/matrix.c **** uint8_t matrix_rows(void) {
 117:quantum/matrix.c ****     return MATRIX_ROWS;
 118:quantum/matrix.c **** }
 119:quantum/matrix.c **** 
 120:quantum/matrix.c **** inline
 121:quantum/matrix.c **** uint8_t matrix_cols(void) {
 129               		.loc 1 121 0
 130               		.cfi_startproc
 131               	/* prologue: function */
 132               	/* frame size = 0 */
 133               	/* stack size = 0 */
 134               	.L__stack_usage = 0
 122:quantum/matrix.c ****     return MATRIX_COLS;
 123:quantum/matrix.c **** }
 135               		.loc 1 123 0
 136 0000 84E0      		ldi r24,lo8(4)
 137 0002 0895      		ret
 138               		.cfi_endproc
 139               	.LFE13:
 141               		.section	.text.matrix_init,"ax",@progbits
 142               	.global	matrix_init
 144               	matrix_init:
 145               	.LFB14:
 124:quantum/matrix.c **** 
 125:quantum/matrix.c **** // void matrix_power_up(void) {
 126:quantum/matrix.c **** // #if (DIODE_DIRECTION == COL2ROW)
 127:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 128:quantum/matrix.c **** //         /* DDRxn */
 129:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 1) |= _BV(row_pins[r] & 0xF);
 130:quantum/matrix.c **** //         toggle_row(r);
 131:quantum/matrix.c **** //     }
 132:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 133:quantum/matrix.c **** //         /* PORTxn */
 134:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 2) |= _BV(col_pins[c] & 0xF);
 135:quantum/matrix.c **** //     }
 136:quantum/matrix.c **** // #else
 137:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 138:quantum/matrix.c **** //         /* DDRxn */
 139:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 1) |= _BV(col_pins[c] & 0xF);
 140:quantum/matrix.c **** //         toggle_col(c);
 141:quantum/matrix.c **** //     }
 142:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 143:quantum/matrix.c **** //         /* PORTxn */
 144:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 2) |= _BV(row_pins[r] & 0xF);
 145:quantum/matrix.c **** //     }
 146:quantum/matrix.c **** // #endif
 147:quantum/matrix.c **** // }
 148:quantum/matrix.c **** 
 149:quantum/matrix.c **** void matrix_init(void) {
 146               		.loc 1 149 0
 147               		.cfi_startproc
 148 0000 CF93      		push r28
 149               	.LCFI0:
 150               		.cfi_def_cfa_offset 3
 151               		.cfi_offset 28, -2
 152 0002 DF93      		push r29
 153               	.LCFI1:
 154               		.cfi_def_cfa_offset 4
 155               		.cfi_offset 29, -3
 156               	/* prologue: function */
 157               	/* frame size = 0 */
 158               	/* stack size = 2 */
 159               	.L__stack_usage = 2
 150:quantum/matrix.c **** 
 151:quantum/matrix.c ****     // To use PORTF disable JTAG with writing JTD bit twice within four cycles.
 152:quantum/matrix.c ****     #if  (defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1287__) || defined(__AVR_ATmega32U4_
 153:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 160               		.loc 1 153 0
 161 0004 85B7      		in r24,0x35
 162 0006 8068      		ori r24,lo8(-128)
 163 0008 85BF      		out 0x35,r24
 154:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 164               		.loc 1 154 0
 165 000a 85B7      		in r24,0x35
 166 000c 8068      		ori r24,lo8(-128)
 167 000e 85BF      		out 0x35,r24
 168               	.LVL4:
 169 0010 A0E0      		ldi r26,lo8(row_pins)
 170 0012 B0E0      		ldi r27,hi8(row_pins)
 171 0014 40E0      		ldi r20,lo8(row_pins+4)
 172 0016 50E0      		ldi r21,hi8(row_pins+4)
 173               	.LBB19:
 174               	.LBB20:
 175               	.LBB21:
 155:quantum/matrix.c ****     #endif
 156:quantum/matrix.c **** 
 157:quantum/matrix.c ****     // initialize row and col
 158:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 159:quantum/matrix.c ****     unselect_rows();
 160:quantum/matrix.c ****     init_cols();
 161:quantum/matrix.c **** #else // ROW2COL
 162:quantum/matrix.c ****     unselect_cols();
 163:quantum/matrix.c ****     init_rows();
 164:quantum/matrix.c **** #endif
 165:quantum/matrix.c **** 
 166:quantum/matrix.c ****     // initialize matrix state: all keys off
 167:quantum/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 168:quantum/matrix.c ****         matrix[i] = 0;
 169:quantum/matrix.c ****         matrix_raw[i] = 0;
 170:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 171:quantum/matrix.c ****     }
 172:quantum/matrix.c **** 
 173:quantum/matrix.c ****     matrix_init_quantum();
 174:quantum/matrix.c **** }
 175:quantum/matrix.c **** 
 176:quantum/matrix.c **** uint8_t matrix_scan(void)
 177:quantum/matrix.c **** {
 178:quantum/matrix.c **** 
 179:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 180:quantum/matrix.c **** 
 181:quantum/matrix.c ****     // Set row, read cols
 182:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < MATRIX_ROWS; current_row++) {
 183:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 184:quantum/matrix.c ****             bool matrix_changed = read_cols_on_row(matrix_debouncing, current_row);
 185:quantum/matrix.c **** 
 186:quantum/matrix.c ****             if (matrix_changed) {
 187:quantum/matrix.c ****                 debouncing = true;
 188:quantum/matrix.c ****                 debouncing_time = timer_read();
 189:quantum/matrix.c ****             }
 190:quantum/matrix.c **** 
 191:quantum/matrix.c **** #       else
 192:quantum/matrix.c ****             read_cols_on_row(matrix, current_row);
 193:quantum/matrix.c **** #       endif
 194:quantum/matrix.c **** 
 195:quantum/matrix.c ****     }
 196:quantum/matrix.c **** 
 197:quantum/matrix.c **** #else // ROW2COL
 198:quantum/matrix.c **** 
 199:quantum/matrix.c ****     // Set col, read rows
 200:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 201:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 202:quantum/matrix.c ****             bool matrix_changed = read_rows_on_col(matrix_debouncing, current_col);
 203:quantum/matrix.c ****             if (matrix_changed) {
 204:quantum/matrix.c ****                 debouncing = true;
 205:quantum/matrix.c ****                 debouncing_time = timer_read();
 206:quantum/matrix.c ****             }
 207:quantum/matrix.c **** #       else
 208:quantum/matrix.c ****              read_rows_on_col(matrix, current_col);
 209:quantum/matrix.c **** #       endif
 210:quantum/matrix.c **** 
 211:quantum/matrix.c ****     }
 212:quantum/matrix.c **** 
 213:quantum/matrix.c **** #endif
 214:quantum/matrix.c **** 
 215:quantum/matrix.c **** #   if (DEBOUNCING_DELAY > 0)
 216:quantum/matrix.c ****         if (debouncing && (timer_elapsed(debouncing_time) > DEBOUNCING_DELAY)) {
 217:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 218:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 219:quantum/matrix.c ****             }
 220:quantum/matrix.c ****             debouncing = false;
 221:quantum/matrix.c ****         }
 222:quantum/matrix.c **** #   endif
 223:quantum/matrix.c **** 
 224:quantum/matrix.c ****     matrix_scan_quantum();
 225:quantum/matrix.c ****     return 1;
 226:quantum/matrix.c **** }
 227:quantum/matrix.c **** 
 228:quantum/matrix.c **** bool matrix_is_modified(void)
 229:quantum/matrix.c **** {
 230:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 231:quantum/matrix.c ****     if (debouncing) return false;
 232:quantum/matrix.c **** #endif
 233:quantum/matrix.c ****     return true;
 234:quantum/matrix.c **** }
 235:quantum/matrix.c **** 
 236:quantum/matrix.c **** inline
 237:quantum/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 238:quantum/matrix.c **** {
 239:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 240:quantum/matrix.c **** }
 241:quantum/matrix.c **** 
 242:quantum/matrix.c **** inline
 243:quantum/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 244:quantum/matrix.c **** {
 245:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 246:quantum/matrix.c ****     // switch blocker installed and the switch is always pressed.
 247:quantum/matrix.c **** #ifdef MATRIX_MASKED
 248:quantum/matrix.c ****     return matrix[row] & matrix_mask[row];
 249:quantum/matrix.c **** #else
 250:quantum/matrix.c ****     return matrix[row];
 251:quantum/matrix.c **** #endif
 252:quantum/matrix.c **** }
 253:quantum/matrix.c **** 
 254:quantum/matrix.c **** void matrix_print(void)
 255:quantum/matrix.c **** {
 256:quantum/matrix.c ****     print_matrix_header();
 257:quantum/matrix.c **** 
 258:quantum/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 259:quantum/matrix.c ****         phex(row); print(": ");
 260:quantum/matrix.c ****         print_matrix_row(row);
 261:quantum/matrix.c ****         print("\n");
 262:quantum/matrix.c ****     }
 263:quantum/matrix.c **** }
 264:quantum/matrix.c **** 
 265:quantum/matrix.c **** uint8_t matrix_key_count(void)
 266:quantum/matrix.c **** {
 267:quantum/matrix.c ****     uint8_t count = 0;
 268:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 269:quantum/matrix.c ****         count += matrix_bitpop(i);
 270:quantum/matrix.c ****     }
 271:quantum/matrix.c ****     return count;
 272:quantum/matrix.c **** }
 273:quantum/matrix.c **** 
 274:quantum/matrix.c **** 
 275:quantum/matrix.c **** 
 276:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 277:quantum/matrix.c **** 
 278:quantum/matrix.c **** static void init_cols(void)
 279:quantum/matrix.c **** {
 280:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 281:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 283:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 284:quantum/matrix.c ****     }
 285:quantum/matrix.c **** }
 286:quantum/matrix.c **** 
 287:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row)
 288:quantum/matrix.c **** {
 289:quantum/matrix.c ****     // Store last value of row prior to reading
 290:quantum/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 291:quantum/matrix.c **** 
 292:quantum/matrix.c ****     // Clear data in matrix row
 293:quantum/matrix.c ****     current_matrix[current_row] = 0;
 294:quantum/matrix.c **** 
 295:quantum/matrix.c ****     // Select row and wait for row selecton to stabilize
 296:quantum/matrix.c ****     select_row(current_row);
 297:quantum/matrix.c ****     wait_us(30);
 298:quantum/matrix.c **** 
 299:quantum/matrix.c ****     // For each col...
 300:quantum/matrix.c ****     for(uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 301:quantum/matrix.c **** 
 302:quantum/matrix.c ****         // Select the col pin to read (active low)
 303:quantum/matrix.c ****         uint8_t pin = col_pins[col_index];
 304:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 305:quantum/matrix.c **** 
 306:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 307:quantum/matrix.c ****         current_matrix[current_row] |=  pin_state ? 0 : (ROW_SHIFTER << col_index);
 308:quantum/matrix.c ****     }
 309:quantum/matrix.c **** 
 310:quantum/matrix.c ****     // Unselect row
 311:quantum/matrix.c ****     unselect_row(current_row);
 312:quantum/matrix.c **** 
 313:quantum/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 314:quantum/matrix.c **** }
 315:quantum/matrix.c **** 
 316:quantum/matrix.c **** static void select_row(uint8_t row)
 317:quantum/matrix.c **** {
 318:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 320:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 321:quantum/matrix.c **** }
 322:quantum/matrix.c **** 
 323:quantum/matrix.c **** static void unselect_row(uint8_t row)
 324:quantum/matrix.c **** {
 325:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 327:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 328:quantum/matrix.c **** }
 329:quantum/matrix.c **** 
 330:quantum/matrix.c **** static void unselect_rows(void)
 331:quantum/matrix.c **** {
 332:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_ROWS; x++) {
 333:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 334:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 176               		.loc 1 334 0
 177 0018 61E0      		ldi r22,lo8(1)
 178 001a 70E0      		ldi r23,0
 179               	.LVL5:
 180               	.L10:
 333:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 181               		.loc 1 333 0
 182 001c 8D91      		ld r24,X+
 183               	.LVL6:
 184               		.loc 1 334 0
 185 001e E82F      		mov r30,r24
 186 0020 E295      		swap r30
 187 0022 EF70      		andi r30,lo8(15)
 188 0024 F0E0      		ldi r31,0
 189 0026 21A1      		ldd r18,Z+33
 190 0028 8F70      		andi r24,lo8(15)
 191               	.LVL7:
 192 002a EB01      		movw r28,r22
 193 002c 00C0      		rjmp 2f
 194               		1:
 195 002e CC0F      		lsl r28
 196 0030 DD1F      		rol r29
 197               		2:
 198 0032 8A95      		dec r24
 199 0034 02F4      		brpl 1b
 200 0036 CE01      		movw r24,r28
 201 0038 9C2F      		mov r25,r28
 202 003a 9095      		com r25
 203 003c 9223      		and r25,r18
 204 003e 91A3      		std Z+33,r25
 205               	.LVL8:
 335:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 206               		.loc 1 335 0
 207 0040 92A1      		ldd r25,Z+34
 208 0042 892B      		or r24,r25
 209 0044 82A3      		std Z+34,r24
 210               	.LVL9:
 211               	.LBE21:
 332:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 212               		.loc 1 332 0
 213 0046 4A17      		cp r20,r26
 214 0048 5B07      		cpc r21,r27
 215 004a 01F4      		brne .L10
 216 004c A0E0      		ldi r26,lo8(col_pins)
 217 004e B0E0      		ldi r27,hi8(col_pins)
 218               	.LVL10:
 219               	.LBE20:
 220               	.LBE19:
 221               	.LBB22:
 222               	.LBB23:
 223               	.LBB24:
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 224               		.loc 1 282 0
 225 0050 41E0      		ldi r20,lo8(1)
 226 0052 50E0      		ldi r21,0
 227               	.L11:
 228               	.LVL11:
 281:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 229               		.loc 1 281 0
 230 0054 8D91      		ld r24,X+
 231               	.LVL12:
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 232               		.loc 1 282 0
 233 0056 E82F      		mov r30,r24
 234 0058 E295      		swap r30
 235 005a EF70      		andi r30,lo8(15)
 236 005c F0E0      		ldi r31,0
 237 005e 21A1      		ldd r18,Z+33
 238 0060 8F70      		andi r24,lo8(15)
 239               	.LVL13:
 240 0062 BA01      		movw r22,r20
 241 0064 00C0      		rjmp 2f
 242               		1:
 243 0066 660F      		lsl r22
 244 0068 771F      		rol r23
 245               		2:
 246 006a 8A95      		dec r24
 247 006c 02F4      		brpl 1b
 248 006e CB01      		movw r24,r22
 249 0070 962F      		mov r25,r22
 250 0072 9095      		com r25
 251 0074 9223      		and r25,r18
 252 0076 91A3      		std Z+33,r25
 253               	.LVL14:
 283:quantum/matrix.c ****     }
 254               		.loc 1 283 0
 255 0078 92A1      		ldd r25,Z+34
 256 007a 892B      		or r24,r25
 257 007c 82A3      		std Z+34,r24
 258               	.LVL15:
 259               	.LBE24:
 280:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 260               		.loc 1 280 0
 261 007e 70E0      		ldi r23,hi8(col_pins+4)
 262 0080 A030      		cpi r26,lo8(col_pins+4)
 263 0082 B707      		cpc r27,r23
 264 0084 01F4      		brne .L11
 265               	.LVL16:
 266               	.LBE23:
 267               	.LBE22:
 268               	.LBB25:
 168:quantum/matrix.c ****         matrix_raw[i] = 0;
 269               		.loc 1 168 0
 270 0086 1092 0000 		sts matrix,__zero_reg__
 170:quantum/matrix.c ****     }
 271               		.loc 1 170 0
 272 008a 1092 0000 		sts matrix_debouncing,__zero_reg__
 273               	.LVL17:
 168:quantum/matrix.c ****         matrix_raw[i] = 0;
 274               		.loc 1 168 0
 275 008e 1092 0000 		sts matrix+1,__zero_reg__
 170:quantum/matrix.c ****     }
 276               		.loc 1 170 0
 277 0092 1092 0000 		sts matrix_debouncing+1,__zero_reg__
 278               	.LVL18:
 168:quantum/matrix.c ****         matrix_raw[i] = 0;
 279               		.loc 1 168 0
 280 0096 1092 0000 		sts matrix+2,__zero_reg__
 170:quantum/matrix.c ****     }
 281               		.loc 1 170 0
 282 009a 1092 0000 		sts matrix_debouncing+2,__zero_reg__
 283               	.LVL19:
 168:quantum/matrix.c ****         matrix_raw[i] = 0;
 284               		.loc 1 168 0
 285 009e 1092 0000 		sts matrix+3,__zero_reg__
 170:quantum/matrix.c ****     }
 286               		.loc 1 170 0
 287 00a2 1092 0000 		sts matrix_debouncing+3,__zero_reg__
 288               	.LVL20:
 289               	/* epilogue start */
 290               	.LBE25:
 174:quantum/matrix.c **** 
 291               		.loc 1 174 0
 292 00a6 DF91      		pop r29
 293 00a8 CF91      		pop r28
 173:quantum/matrix.c **** }
 294               		.loc 1 173 0
 295 00aa 0C94 0000 		jmp matrix_init_quantum
 296               	.LVL21:
 297               		.cfi_endproc
 298               	.LFE14:
 300               		.section	.text.matrix_scan,"ax",@progbits
 301               	.global	matrix_scan
 303               	matrix_scan:
 304               	.LFB15:
 177:quantum/matrix.c **** 
 305               		.loc 1 177 0
 306               		.cfi_startproc
 307 0000 6F92      		push r6
 308               	.LCFI2:
 309               		.cfi_def_cfa_offset 3
 310               		.cfi_offset 6, -2
 311 0002 7F92      		push r7
 312               	.LCFI3:
 313               		.cfi_def_cfa_offset 4
 314               		.cfi_offset 7, -3
 315 0004 8F92      		push r8
 316               	.LCFI4:
 317               		.cfi_def_cfa_offset 5
 318               		.cfi_offset 8, -4
 319 0006 9F92      		push r9
 320               	.LCFI5:
 321               		.cfi_def_cfa_offset 6
 322               		.cfi_offset 9, -5
 323 0008 AF92      		push r10
 324               	.LCFI6:
 325               		.cfi_def_cfa_offset 7
 326               		.cfi_offset 10, -6
 327 000a BF92      		push r11
 328               	.LCFI7:
 329               		.cfi_def_cfa_offset 8
 330               		.cfi_offset 11, -7
 331 000c CF92      		push r12
 332               	.LCFI8:
 333               		.cfi_def_cfa_offset 9
 334               		.cfi_offset 12, -8
 335 000e DF92      		push r13
 336               	.LCFI9:
 337               		.cfi_def_cfa_offset 10
 338               		.cfi_offset 13, -9
 339 0010 EF92      		push r14
 340               	.LCFI10:
 341               		.cfi_def_cfa_offset 11
 342               		.cfi_offset 14, -10
 343 0012 FF92      		push r15
 344               	.LCFI11:
 345               		.cfi_def_cfa_offset 12
 346               		.cfi_offset 15, -11
 347 0014 0F93      		push r16
 348               	.LCFI12:
 349               		.cfi_def_cfa_offset 13
 350               		.cfi_offset 16, -12
 351 0016 1F93      		push r17
 352               	.LCFI13:
 353               		.cfi_def_cfa_offset 14
 354               		.cfi_offset 17, -13
 355 0018 CF93      		push r28
 356               	.LCFI14:
 357               		.cfi_def_cfa_offset 15
 358               		.cfi_offset 28, -14
 359 001a DF93      		push r29
 360               	.LCFI15:
 361               		.cfi_def_cfa_offset 16
 362               		.cfi_offset 29, -15
 363               	/* prologue: function */
 364               	/* frame size = 0 */
 365               	/* stack size = 14 */
 366               	.L__stack_usage = 14
 367               	.LVL22:
 368 001c 00E0      		ldi r16,lo8(row_pins)
 369 001e 10E0      		ldi r17,hi8(row_pins)
 370 0020 C0E0      		ldi r28,lo8(matrix_debouncing)
 371 0022 D0E0      		ldi r29,hi8(matrix_debouncing)
 372               	.LBB39:
 373               	.LBB40:
 374               	.LBB41:
 375               	.LBB42:
 376               	.LBB43:
 377               	.LBB44:
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 378               		.loc 1 319 0
 379 0024 EE24      		clr r14
 380 0026 E394      		inc r14
 381 0028 F12C      		mov r15,__zero_reg__
 382               	.LBE44:
 383               	.LBE43:
 384               	.LBE42:
 385               	.LBE41:
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 386               		.loc 1 187 0
 387 002a DD24      		clr r13
 388 002c D394      		inc r13
 389               	.LVL23:
 390               	.L19:
 391 002e BE01      		movw r22,r28
 392               	.LBB54:
 393               	.LBB53:
 290:quantum/matrix.c **** 
 394               		.loc 1 290 0
 395 0030 9880      		ld r9,Y
 396               	.LVL24:
 293:quantum/matrix.c **** 
 397               		.loc 1 293 0
 398 0032 1882      		st Y,__zero_reg__
 399               	.LVL25:
 400               	.LBB46:
 401               	.LBB45:
 318:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 402               		.loc 1 318 0
 403 0034 D801      		movw r26,r16
 404 0036 8D91      		ld r24,X+
 405 0038 8D01      		movw r16,r26
 406               	.LVL26:
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 407               		.loc 1 319 0
 408 003a E82F      		mov r30,r24
 409 003c E295      		swap r30
 410 003e EF70      		andi r30,lo8(15)
 411 0040 F0E0      		ldi r31,0
 412 0042 91A1      		ldd r25,Z+33
 413 0044 8F70      		andi r24,lo8(15)
 414               	.LVL27:
 415 0046 9701      		movw r18,r14
 416 0048 00C0      		rjmp 2f
 417               		1:
 418 004a 220F      		lsl r18
 419               		2:
 420 004c 8A95      		dec r24
 421 004e 02F4      		brpl 1b
 422 0050 892F      		mov r24,r25
 423 0052 822B      		or r24,r18
 424 0054 81A3      		std Z+33,r24
 425               	.LVL28:
 320:quantum/matrix.c **** }
 426               		.loc 1 320 0
 427 0056 82A1      		ldd r24,Z+34
 428 0058 C22E      		mov r12,r18
 429 005a C094      		com r12
 430 005c 8C21      		and r24,r12
 431 005e 82A3      		std Z+34,r24
 432               	.LVL29:
 433               	.LBE45:
 434               	.LBE46:
 435               	.LBB47:
 436               	.LBB48:
 437               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 438               		.loc 2 276 0
 439 0060 B0EA      		ldi r27,lo8(-96)
 440 0062 BA95      	1:	dec r27
 441 0064 01F4      		brne 1b
 442               	.LVL30:
 443 0066 80E0      		ldi r24,lo8(col_pins)
 444 0068 682E      		mov r6,r24
 445 006a 80E0      		ldi r24,hi8(col_pins)
 446 006c 782E      		mov r7,r24
 447 006e 40E0      		ldi r20,0
 448 0070 50E0      		ldi r21,0
 449               	.LVL31:
 450               	.L17:
 451               	.LBE48:
 452               	.LBE47:
 453               	.LBB49:
 454               	.LBB50:
 303:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 455               		.loc 1 303 0
 456 0072 D301      		movw r26,r6
 457 0074 BD90      		ld r11,X+
 458 0076 3D01      		movw r6,r26
 459               	.LVL32:
 304:quantum/matrix.c **** 
 460               		.loc 1 304 0
 461 0078 8B2D      		mov r24,r11
 462 007a 8295      		swap r24
 463 007c 8F70      		andi r24,lo8(15)
 464 007e 90E0      		ldi r25,0
 465 0080 DC01      		movw r26,r24
 466 0082 9096      		adiw r26,32
 467 0084 8C91      		ld r24,X
 468               	.LVL33:
 307:quantum/matrix.c ****     }
 469               		.loc 1 307 0
 470 0086 8880      		ld r8,Y
 471 0088 9B2D      		mov r25,r11
 472 008a 9F70      		andi r25,lo8(15)
 473               	.LVL34:
 474 008c 5701      		movw r10,r14
 475 008e 00C0      		rjmp 2f
 476               		1:
 477 0090 AA0C      		lsl r10
 478               		2:
 479 0092 9A95      		dec r25
 480 0094 02F4      		brpl 1b
 481 0096 A822      		and r10,r24
 482 0098 01F4      		brne .L23
 483 009a 9E2D      		mov r25,r14
 484               	.LVL35:
 485 009c 042E      		mov r0,r20
 486 009e 00C0      		rjmp 2f
 487               		1:
 488 00a0 990F      		lsl r25
 489               		2:
 490 00a2 0A94      		dec r0
 491 00a4 02F4      		brpl 1b
 492 00a6 892F      		mov r24,r25
 493               	.LVL36:
 494 00a8 00C0      		rjmp .L16
 495               	.LVL37:
 496               	.L23:
 497 00aa 80E0      		ldi r24,0
 498               	.LVL38:
 499               	.L16:
 500 00ac 8829      		or r24,r8
 501 00ae 8883      		st Y,r24
 502               	.LVL39:
 503 00b0 4F5F      		subi r20,-1
 504 00b2 5F4F      		sbci r21,-1
 505               	.LVL40:
 506               	.LBE50:
 300:quantum/matrix.c **** 
 507               		.loc 1 300 0
 508 00b4 4430      		cpi r20,4
 509 00b6 5105      		cpc r21,__zero_reg__
 510 00b8 01F4      		brne .L17
 511               	.LVL41:
 512               	.LBE49:
 513               	.LBB51:
 514               	.LBB52:
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 515               		.loc 1 326 0
 516 00ba 81A1      		ldd r24,Z+33
 517 00bc C822      		and r12,r24
 518 00be C1A2      		std Z+33,r12
 327:quantum/matrix.c **** }
 519               		.loc 1 327 0
 520 00c0 82A1      		ldd r24,Z+34
 521 00c2 282B      		or r18,r24
 522 00c4 22A3      		std Z+34,r18
 523               	.LVL42:
 524 00c6 2196      		adiw r28,1
 525               	.LVL43:
 526               	.LBE52:
 527               	.LBE51:
 528               	.LBE53:
 529               	.LBE54:
 186:quantum/matrix.c ****                 debouncing = true;
 530               		.loc 1 186 0
 531 00c8 FB01      		movw r30,r22
 532 00ca 8081      		ld r24,Z
 533 00cc 9816      		cp r9,r24
 534 00ce 01F0      		breq .L18
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 535               		.loc 1 187 0
 536 00d0 D092 0000 		sts debouncing,r13
 188:quantum/matrix.c ****             }
 537               		.loc 1 188 0
 538 00d4 0E94 0000 		call timer_read
 539               	.LVL44:
 540 00d8 9093 0000 		sts debouncing_time+1,r25
 541 00dc 8093 0000 		sts debouncing_time,r24
 542               	.L18:
 543               	.LVL45:
 544               	.LBE40:
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 545               		.loc 1 182 0 discriminator 2
 546 00e0 F0E0      		ldi r31,hi8(matrix_debouncing+4)
 547 00e2 C030      		cpi r28,lo8(matrix_debouncing+4)
 548 00e4 DF07      		cpc r29,r31
 549 00e6 01F0      		breq .+2
 550 00e8 00C0      		rjmp .L19
 551               	.LBE39:
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 552               		.loc 1 216 0
 553 00ea 8091 0000 		lds r24,debouncing
 554 00ee 8823      		tst r24
 555 00f0 01F0      		breq .L21
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 556               		.loc 1 216 0 is_stmt 0 discriminator 1
 557 00f2 8091 0000 		lds r24,debouncing_time
 558 00f6 9091 0000 		lds r25,debouncing_time+1
 559 00fa 0E94 0000 		call timer_elapsed
 560               	.LVL46:
 561 00fe 0697      		sbiw r24,6
 562 0100 00F0      		brlo .L21
 563               	.LVL47:
 564               	.LBB55:
 218:quantum/matrix.c ****             }
 565               		.loc 1 218 0 is_stmt 1
 566 0102 8091 0000 		lds r24,matrix_debouncing
 567 0106 8093 0000 		sts matrix,r24
 568               	.LVL48:
 569 010a 8091 0000 		lds r24,matrix_debouncing+1
 570 010e 8093 0000 		sts matrix+1,r24
 571               	.LVL49:
 572 0112 8091 0000 		lds r24,matrix_debouncing+2
 573 0116 8093 0000 		sts matrix+2,r24
 574               	.LVL50:
 575 011a 8091 0000 		lds r24,matrix_debouncing+3
 576 011e 8093 0000 		sts matrix+3,r24
 577               	.LVL51:
 578               	.LBE55:
 220:quantum/matrix.c ****         }
 579               		.loc 1 220 0
 580 0122 1092 0000 		sts debouncing,__zero_reg__
 581               	.LVL52:
 582               	.L21:
 224:quantum/matrix.c ****     return 1;
 583               		.loc 1 224 0
 584 0126 0E94 0000 		call matrix_scan_quantum
 585               	.LVL53:
 226:quantum/matrix.c **** 
 586               		.loc 1 226 0
 587 012a 81E0      		ldi r24,lo8(1)
 588               	/* epilogue start */
 589 012c DF91      		pop r29
 590 012e CF91      		pop r28
 591               	.LVL54:
 592 0130 1F91      		pop r17
 593 0132 0F91      		pop r16
 594 0134 FF90      		pop r15
 595 0136 EF90      		pop r14
 596 0138 DF90      		pop r13
 597 013a CF90      		pop r12
 598 013c BF90      		pop r11
 599 013e AF90      		pop r10
 600 0140 9F90      		pop r9
 601 0142 8F90      		pop r8
 602 0144 7F90      		pop r7
 603 0146 6F90      		pop r6
 604 0148 0895      		ret
 605               		.cfi_endproc
 606               	.LFE15:
 608               		.section	.text.matrix_is_modified,"ax",@progbits
 609               	.global	matrix_is_modified
 611               	matrix_is_modified:
 612               	.LFB16:
 229:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 613               		.loc 1 229 0
 614               		.cfi_startproc
 615               	/* prologue: function */
 616               	/* frame size = 0 */
 617               	/* stack size = 0 */
 618               	.L__stack_usage = 0
 619 0000 9091 0000 		lds r25,debouncing
 234:quantum/matrix.c **** 
 620               		.loc 1 234 0
 621 0004 81E0      		ldi r24,lo8(1)
 622 0006 8927      		eor r24,r25
 623 0008 0895      		ret
 624               		.cfi_endproc
 625               	.LFE16:
 627               		.section	.text.matrix_is_on,"ax",@progbits
 628               	.global	matrix_is_on
 630               	matrix_is_on:
 631               	.LFB17:
 238:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 632               		.loc 1 238 0
 633               		.cfi_startproc
 634               	.LVL55:
 635               	/* prologue: function */
 636               	/* frame size = 0 */
 637               	/* stack size = 0 */
 638               	.L__stack_usage = 0
 239:quantum/matrix.c **** }
 639               		.loc 1 239 0
 640 0000 E82F      		mov r30,r24
 641 0002 F0E0      		ldi r31,0
 642 0004 E050      		subi r30,lo8(-(matrix))
 643 0006 F040      		sbci r31,hi8(-(matrix))
 644 0008 8081      		ld r24,Z
 645               	.LVL56:
 646 000a 282F      		mov r18,r24
 647 000c 30E0      		ldi r19,0
 648 000e 81E0      		ldi r24,lo8(1)
 649 0010 90E0      		ldi r25,0
 650 0012 6230      		cpi r22,lo8(2)
 651 0014 00F4      		brsh .L28
 652 0016 80E0      		ldi r24,0
 653 0018 90E0      		ldi r25,0
 654               	.L28:
 655 001a 8223      		and r24,r18
 656 001c 9323      		and r25,r19
 240:quantum/matrix.c **** 
 657               		.loc 1 240 0
 658 001e 8170      		andi r24,lo8(1)
 659 0020 0895      		ret
 660               		.cfi_endproc
 661               	.LFE17:
 663               		.section	.text.matrix_get_row,"ax",@progbits
 664               	.global	matrix_get_row
 666               	matrix_get_row:
 667               	.LFB18:
 244:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 668               		.loc 1 244 0
 669               		.cfi_startproc
 670               	.LVL57:
 671               	/* prologue: function */
 672               	/* frame size = 0 */
 673               	/* stack size = 0 */
 674               	.L__stack_usage = 0
 250:quantum/matrix.c **** #endif
 675               		.loc 1 250 0
 676 0000 E82F      		mov r30,r24
 677 0002 F0E0      		ldi r31,0
 678 0004 E050      		subi r30,lo8(-(matrix))
 679 0006 F040      		sbci r31,hi8(-(matrix))
 252:quantum/matrix.c **** 
 680               		.loc 1 252 0
 681 0008 8081      		ld r24,Z
 682               	.LVL58:
 683 000a 0895      		ret
 684               		.cfi_endproc
 685               	.LFE18:
 687               		.section	.text.matrix_print,"ax",@progbits
 688               	.global	matrix_print
 690               	matrix_print:
 691               	.LFB19:
 255:quantum/matrix.c ****     print_matrix_header();
 692               		.loc 1 255 0
 693               		.cfi_startproc
 694               	/* prologue: function */
 695               	/* frame size = 0 */
 696               	/* stack size = 0 */
 697               	.L__stack_usage = 0
 698               	.LVL59:
 699 0000 0895      		ret
 700               		.cfi_endproc
 701               	.LFE19:
 703               		.section	.text.matrix_key_count,"ax",@progbits
 704               	.global	matrix_key_count
 706               	matrix_key_count:
 707               	.LFB20:
 266:quantum/matrix.c ****     uint8_t count = 0;
 708               		.loc 1 266 0
 709               		.cfi_startproc
 266:quantum/matrix.c ****     uint8_t count = 0;
 710               		.loc 1 266 0
 711 0000 0F93      		push r16
 712               	.LCFI16:
 713               		.cfi_def_cfa_offset 3
 714               		.cfi_offset 16, -2
 715 0002 1F93      		push r17
 716               	.LCFI17:
 717               		.cfi_def_cfa_offset 4
 718               		.cfi_offset 17, -3
 719 0004 CF93      		push r28
 720               	.LCFI18:
 721               		.cfi_def_cfa_offset 5
 722               		.cfi_offset 28, -4
 723               	/* prologue: function */
 724               	/* frame size = 0 */
 725               	/* stack size = 3 */
 726               	.L__stack_usage = 3
 727               	.LVL60:
 728 0006 00E0      		ldi r16,lo8(matrix)
 729 0008 10E0      		ldi r17,hi8(matrix)
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 730               		.loc 1 267 0
 731 000a C0E0      		ldi r28,0
 732               	.LVL61:
 733               	.L32:
 734               	.LBB56:
 269:quantum/matrix.c ****     }
 735               		.loc 1 269 0 discriminator 3
 736 000c F801      		movw r30,r16
 737 000e 8191      		ld r24,Z+
 738 0010 8F01      		movw r16,r30
 739               	.LVL62:
 740 0012 0E94 0000 		call bitpop
 741               	.LVL63:
 742 0016 C80F      		add r28,r24
 743               	.LVL64:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 744               		.loc 1 268 0 discriminator 3
 745 0018 F0E0      		ldi r31,hi8(matrix+4)
 746 001a 0030      		cpi r16,lo8(matrix+4)
 747 001c 1F07      		cpc r17,r31
 748 001e 01F4      		brne .L32
 749               	.LBE56:
 272:quantum/matrix.c **** 
 750               		.loc 1 272 0
 751 0020 8C2F      		mov r24,r28
 752               	/* epilogue start */
 753 0022 CF91      		pop r28
 754               	.LVL65:
 755 0024 1F91      		pop r17
 756 0026 0F91      		pop r16
 757               	.LVL66:
 758 0028 0895      		ret
 759               		.cfi_endproc
 760               	.LFE20:
 762               		.section	.bss.matrix_debouncing,"aw",@nobits
 765               	matrix_debouncing:
 766 0000 0000 0000 		.zero	4
 767               		.section	.bss.matrix,"aw",@nobits
 770               	matrix:
 771 0000 0000 0000 		.zero	4
 772               		.section	.rodata.col_pins,"a",@progbits
 775               	col_pins:
 776 0000 F5        		.byte	-11
 777 0001 F4        		.byte	-12
 778 0002 F1        		.byte	-15
 779 0003 F0        		.byte	-16
 780               		.section	.rodata.row_pins,"a",@progbits
 783               	row_pins:
 784 0000 67        		.byte	103
 785 0001 66        		.byte	102
 786 0002 F7        		.byte	-9
 787 0003 F6        		.byte	-10
 788               		.section	.bss.debouncing,"aw",@nobits
 791               	debouncing:
 792 0000 00        		.zero	1
 793               		.section	.bss.debouncing_time,"aw",@nobits
 796               	debouncing_time:
 797 0000 0000      		.zero	2
 798               		.text
 799               	.Letext0:
 800               		.file 3 "/usr/lib/avr/include/stdint.h"
 801               		.file 4 "./tmk_core/common/matrix.h"
 802               		.file 5 "./tmk_core/common/timer.h"
 803               		.file 6 "./tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccRAhQk1.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccRAhQk1.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccRAhQk1.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccRAhQk1.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccRAhQk1.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccRAhQk1.s:13     .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/ccRAhQk1.s:13     .text.matrix_scan_user:0000000000000000 matrix_scan_user.localalias.0
     /tmp/ccRAhQk1.s:30     .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/ccRAhQk1.s:44     .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/ccRAhQk1.s:61     .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccRAhQk1.s:78     .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/ccRAhQk1.s:95     .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccRAhQk1.s:112    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccRAhQk1.s:127    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccRAhQk1.s:144    .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccRAhQk1.s:783    .rodata.row_pins:0000000000000000 row_pins
     /tmp/ccRAhQk1.s:775    .rodata.col_pins:0000000000000000 col_pins
     /tmp/ccRAhQk1.s:770    .bss.matrix:0000000000000000 matrix
     /tmp/ccRAhQk1.s:765    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/ccRAhQk1.s:303    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccRAhQk1.s:791    .bss.debouncing:0000000000000000 debouncing
     /tmp/ccRAhQk1.s:796    .bss.debouncing_time:0000000000000000 debouncing_time
     /tmp/ccRAhQk1.s:611    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccRAhQk1.s:630    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccRAhQk1.s:666    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccRAhQk1.s:690    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccRAhQk1.s:706    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
timer_read
timer_elapsed
bitpop
__do_copy_data
__do_clear_bss
