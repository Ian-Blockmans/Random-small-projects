   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB108:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** #ifdef POINTING_DEVICE_ENABLE
  41:tmk_core/common/action.c **** #    include "pointing_device.h"
  42:tmk_core/common/action.c **** #endif
  43:tmk_core/common/action.c **** 
  44:tmk_core/common/action.c **** int tp_buttons;
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  47:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  51:tmk_core/common/action.c **** #    include <fauxclicky.h>
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** 
  54:tmk_core/common/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  55:tmk_core/common/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) { re
  56:tmk_core/common/action.c **** #endif
  57:tmk_core/common/action.c **** 
  58:tmk_core/common/action.c **** #ifdef RETRO_TAPPING_PER_KEY
  59:tmk_core/common/action.c **** __attribute__((weak)) bool get_retro_tapping(uint16_t keycode, keyrecord_t *record) { return false;
  60:tmk_core/common/action.c **** #endif
  61:tmk_core/common/action.c **** 
  62:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  63:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  64:tmk_core/common/action.c **** #endif
  65:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  66:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  67:tmk_core/common/action.c **** #endif
  68:tmk_core/common/action.c **** /** \brief Called to execute an action.
  69:tmk_core/common/action.c ****  *
  70:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  71:tmk_core/common/action.c ****  */
  72:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  16               		.loc 1 72 0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  73:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  74:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  75:tmk_core/common/action.c ****         dprint("EVENT: ");
  76:tmk_core/common/action.c ****         debug_event(event);
  77:tmk_core/common/action.c ****         dprintln();
  78:tmk_core/common/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  79:tmk_core/common/action.c ****         retro_tapping_counter++;
  80:tmk_core/common/action.c **** #endif
  81:tmk_core/common/action.c ****     }
  82:tmk_core/common/action.c **** 
  83:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  84:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  85:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  86:tmk_core/common/action.c ****     }
  87:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  88:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  89:tmk_core/common/action.c ****     }
  90:tmk_core/common/action.c ****     fauxclicky_check();
  91:tmk_core/common/action.c **** #endif
  92:tmk_core/common/action.c **** 
  93:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  94:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  95:tmk_core/common/action.c ****         process_hand_swap(&event);
  96:tmk_core/common/action.c ****     }
  97:tmk_core/common/action.c **** #endif
  98:tmk_core/common/action.c **** 
  99:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  48               		.loc 1 99 0
  49 001e DE01      		movw r26,r28
  50 0020 1196      		adiw r26,1
  51 0022 86E0      		ldi r24,lo8(6)
  52 0024 FD01      		movw r30,r26
  53               		0:
  54 0026 1192      		st Z+,__zero_reg__
  55 0028 8A95      		dec r24
  56 002a 01F4      		brne 0b
  57 002c 85E0      		ldi r24,lo8(5)
  58 002e FE01      		movw r30,r28
  59 0030 3796      		adiw r30,7
  60               		0:
  61 0032 0190      		ld r0,Z+
  62 0034 0D92      		st X+,r0
  63 0036 8A95      		dec r24
  64 0038 01F4      		brne 0b
 100:tmk_core/common/action.c **** 
 101:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 102:tmk_core/common/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
 103:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
 104:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 105:tmk_core/common/action.c ****     }
 106:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
 107:tmk_core/common/action.c ****         clear_oneshot_mods();
 108:tmk_core/common/action.c ****     }
 109:tmk_core/common/action.c **** #        ifdef SWAP_HANDS_ENABLE
 110:tmk_core/common/action.c ****     if (has_oneshot_swaphands_timed_out()) {
 111:tmk_core/common/action.c ****         clear_oneshot_swaphands();
 112:tmk_core/common/action.c ****     }
 113:tmk_core/common/action.c **** #        endif
 114:tmk_core/common/action.c **** #    endif
 115:tmk_core/common/action.c **** #endif
 116:tmk_core/common/action.c **** 
 117:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 118:tmk_core/common/action.c ****     action_tapping_process(record);
  65               		.loc 1 118 0
  66 003a 4981      		ldd r20,Y+1
  67               	.LVL1:
  68 003c 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70 003e 6B81      		ldd r22,Y+3
  71 0040 7C81      		ldd r23,Y+4
  72 0042 8D81      		ldd r24,Y+5
  73 0044 9E81      		ldd r25,Y+6
  74 0046 0E94 0000 		call action_tapping_process
  75               	.LVL3:
  76               	/* epilogue start */
 119:tmk_core/common/action.c **** #else
 120:tmk_core/common/action.c ****     process_record(&record);
 121:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 122:tmk_core/common/action.c ****         dprint("processed: ");
 123:tmk_core/common/action.c ****         debug_record(record);
 124:tmk_core/common/action.c ****         dprintln();
 125:tmk_core/common/action.c ****     }
 126:tmk_core/common/action.c **** #endif
 127:tmk_core/common/action.c **** }
  77               		.loc 1 127 0
  78 004a 2B96      		adiw r28,11
  79 004c 0FB6      		in __tmp_reg__,__SREG__
  80 004e F894      		cli
  81 0050 DEBF      		out __SP_H__,r29
  82 0052 0FBE      		out __SREG__,__tmp_reg__
  83 0054 CDBF      		out __SP_L__,r28
  84 0056 DF91      		pop r29
  85 0058 CF91      		pop r28
  86 005a 0895      		ret
  87               		.cfi_endproc
  88               	.LFE108:
  90               		.section	.text.process_record_quantum,"ax",@progbits
  91               		.weak	process_record_quantum
  93               	process_record_quantum:
  94               	.LFB110:
 128:tmk_core/common/action.c **** 
 129:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 130:tmk_core/common/action.c **** bool swap_hands = false;
 131:tmk_core/common/action.c **** bool swap_held  = false;
 132:tmk_core/common/action.c **** 
 133:tmk_core/common/action.c **** /** \brief Process Hand Swap
 134:tmk_core/common/action.c ****  *
 135:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 136:tmk_core/common/action.c ****  */
 137:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 138:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 139:tmk_core/common/action.c **** 
 140:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 141:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 142:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 143:tmk_core/common/action.c **** 
 144:tmk_core/common/action.c ****     if (do_swap) {
 145:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 146:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 147:tmk_core/common/action.c ****     } else {
 148:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 149:tmk_core/common/action.c ****     }
 150:tmk_core/common/action.c **** }
 151:tmk_core/common/action.c **** #endif
 152:tmk_core/common/action.c **** 
 153:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 154:tmk_core/common/action.c **** bool disable_action_cache = false;
 155:tmk_core/common/action.c **** 
 156:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 157:tmk_core/common/action.c ****     disable_action_cache = true;
 158:tmk_core/common/action.c ****     process_record(record);
 159:tmk_core/common/action.c ****     disable_action_cache = false;
 160:tmk_core/common/action.c **** }
 161:tmk_core/common/action.c **** #else
 162:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 163:tmk_core/common/action.c **** #endif
 164:tmk_core/common/action.c **** 
 165:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  95               		.loc 1 165 0
  96               		.cfi_startproc
  97               	.LVL4:
  98               	/* prologue: function */
  99               	/* frame size = 0 */
 100               	/* stack size = 0 */
 101               	.L__stack_usage = 0
 102               		.loc 1 165 0
 103 0000 81E0      		ldi r24,lo8(1)
 104               	.LVL5:
 105 0002 0895      		ret
 106               		.cfi_endproc
 107               	.LFE110:
 109               		.section	.text.post_process_record_quantum,"ax",@progbits
 110               		.weak	post_process_record_quantum
 112               	post_process_record_quantum:
 113               	.LFB111:
 166:tmk_core/common/action.c **** 
 167:tmk_core/common/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 114               		.loc 1 167 0
 115               		.cfi_startproc
 116               	.LVL6:
 117               	/* prologue: function */
 118               	/* frame size = 0 */
 119               	/* stack size = 0 */
 120               	.L__stack_usage = 0
 121 0000 0895      		ret
 122               		.cfi_endproc
 123               	.LFE111:
 125               		.section	.text.process_record_tap_hint,"ax",@progbits
 126               	.global	process_record_tap_hint
 128               	process_record_tap_hint:
 129               	.LFB112:
 168:tmk_core/common/action.c **** 
 169:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 170:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 171:tmk_core/common/action.c ****  *
 172:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 173:tmk_core/common/action.c ****  */
 174:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 130               		.loc 1 174 0
 131               		.cfi_startproc
 132               	.LVL7:
 133               	/* prologue: function */
 134               	/* frame size = 0 */
 135               	/* stack size = 0 */
 136               	.L__stack_usage = 0
 175:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 137               		.loc 1 175 0
 138 0000 FC01      		movw r30,r24
 139 0002 8081      		ld r24,Z
 140 0004 9181      		ldd r25,Z+1
 141               	.LVL8:
 142 0006 0E94 0000 		call layer_switch_get_action
 143               	.LVL9:
 144 000a 0895      		ret
 145               		.cfi_endproc
 146               	.LFE112:
 148               		.section	.text.register_code,"ax",@progbits
 149               	.global	register_code
 151               	register_code:
 152               	.LFB116:
 176:tmk_core/common/action.c **** 
 177:tmk_core/common/action.c ****     switch (action.kind.id) {
 178:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 179:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 180:tmk_core/common/action.c ****             switch (action.swap.code) {
 181:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 182:tmk_core/common/action.c ****                     break;
 183:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 184:tmk_core/common/action.c ****                 default:
 185:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 186:tmk_core/common/action.c ****                     swap_held  = true;
 187:tmk_core/common/action.c ****             }
 188:tmk_core/common/action.c ****             break;
 189:tmk_core/common/action.c **** #    endif
 190:tmk_core/common/action.c ****     }
 191:tmk_core/common/action.c **** }
 192:tmk_core/common/action.c **** #endif
 193:tmk_core/common/action.c **** 
 194:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 195:tmk_core/common/action.c ****  *
 196:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 197:tmk_core/common/action.c ****  */
 198:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 199:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 200:tmk_core/common/action.c ****         return;
 201:tmk_core/common/action.c ****     }
 202:tmk_core/common/action.c **** 
 203:tmk_core/common/action.c ****     if (!process_record_quantum(record)) {
 204:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 205:tmk_core/common/action.c ****         if (is_oneshot_layer_active() && record->event.pressed) {
 206:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 207:tmk_core/common/action.c ****         }
 208:tmk_core/common/action.c **** #endif
 209:tmk_core/common/action.c ****         return;
 210:tmk_core/common/action.c ****     }
 211:tmk_core/common/action.c **** 
 212:tmk_core/common/action.c ****     process_record_handler(record);
 213:tmk_core/common/action.c ****     post_process_record_quantum(record);
 214:tmk_core/common/action.c **** }
 215:tmk_core/common/action.c **** 
 216:tmk_core/common/action.c **** void process_record_handler(keyrecord_t *record) {
 217:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 218:tmk_core/common/action.c ****     dprint("ACTION: ");
 219:tmk_core/common/action.c ****     debug_action(action);
 220:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 221:tmk_core/common/action.c ****     dprint(" layer_state: ");
 222:tmk_core/common/action.c ****     layer_debug();
 223:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 224:tmk_core/common/action.c ****     default_layer_debug();
 225:tmk_core/common/action.c **** #endif
 226:tmk_core/common/action.c ****     dprintln();
 227:tmk_core/common/action.c **** 
 228:tmk_core/common/action.c ****     process_action(record, action);
 229:tmk_core/common/action.c **** }
 230:tmk_core/common/action.c **** 
 231:tmk_core/common/action.c **** #if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 232:tmk_core/common/action.c **** void register_button(bool pressed, enum mouse_buttons button) {
 233:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 234:tmk_core/common/action.c ****     tp_buttons = pressed ? tp_buttons | button : tp_buttons & ~button;
 235:tmk_core/common/action.c **** #    endif
 236:tmk_core/common/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 237:tmk_core/common/action.c ****     report_mouse_t currentReport = pointing_device_get_report();
 238:tmk_core/common/action.c ****     currentReport.buttons        = pressed ? currentReport.buttons | button : currentReport.buttons
 239:tmk_core/common/action.c ****     pointing_device_set_report(currentReport);
 240:tmk_core/common/action.c **** #    endif
 241:tmk_core/common/action.c **** }
 242:tmk_core/common/action.c **** #endif
 243:tmk_core/common/action.c **** 
 244:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 245:tmk_core/common/action.c ****  *
 246:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 247:tmk_core/common/action.c ****  */
 248:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 249:tmk_core/common/action.c ****     keyevent_t event = record->event;
 250:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 251:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 252:tmk_core/common/action.c **** #endif
 253:tmk_core/common/action.c **** 
 254:tmk_core/common/action.c ****     if (event.pressed) {
 255:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 256:tmk_core/common/action.c ****         clear_weak_mods();
 257:tmk_core/common/action.c ****     }
 258:tmk_core/common/action.c **** 
 259:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 260:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 261:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 262:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && (action.kind.id == ACT_USAGE || !IS_MOD(actio
 263:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 264:tmk_core/common/action.c ****         && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)
 265:tmk_core/common/action.c **** #    endif
 266:tmk_core/common/action.c ****     ) {
 267:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 268:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 269:tmk_core/common/action.c ****     }
 270:tmk_core/common/action.c **** #endif
 271:tmk_core/common/action.c **** 
 272:tmk_core/common/action.c ****     switch (action.kind.id) {
 273:tmk_core/common/action.c ****         /* Key and Mods */
 274:tmk_core/common/action.c ****         case ACT_LMODS:
 275:tmk_core/common/action.c ****         case ACT_RMODS: {
 276:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 277:tmk_core/common/action.c ****             if (event.pressed) {
 278:tmk_core/common/action.c ****                 if (mods) {
 279:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 280:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 281:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 282:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 283:tmk_core/common/action.c ****                         add_mods(mods);
 284:tmk_core/common/action.c ****                     } else {
 285:tmk_core/common/action.c ****                         add_weak_mods(mods);
 286:tmk_core/common/action.c ****                     }
 287:tmk_core/common/action.c ****                     send_keyboard_report();
 288:tmk_core/common/action.c ****                 }
 289:tmk_core/common/action.c ****                 register_code(action.key.code);
 290:tmk_core/common/action.c ****             } else {
 291:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 292:tmk_core/common/action.c ****                 if (mods) {
 293:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 294:tmk_core/common/action.c ****                         del_mods(mods);
 295:tmk_core/common/action.c ****                     } else {
 296:tmk_core/common/action.c ****                         del_weak_mods(mods);
 297:tmk_core/common/action.c ****                     }
 298:tmk_core/common/action.c ****                     send_keyboard_report();
 299:tmk_core/common/action.c ****                 }
 300:tmk_core/common/action.c ****             }
 301:tmk_core/common/action.c ****         } break;
 302:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 303:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 304:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 305:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 306:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 307:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 308:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 309:tmk_core/common/action.c ****                     // Oneshot modifier
 310:tmk_core/common/action.c ****                     if (event.pressed) {
 311:tmk_core/common/action.c ****                         if (tap_count == 0) {
 312:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 313:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 314:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 315:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 316:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 317:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 318:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 319:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 320:tmk_core/common/action.c ****                             clear_oneshot_mods();
 321:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 322:tmk_core/common/action.c ****                             register_mods(mods);
 323:tmk_core/common/action.c **** #        endif
 324:tmk_core/common/action.c ****                         } else {
 325:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 326:tmk_core/common/action.c ****                         }
 327:tmk_core/common/action.c ****                     } else {
 328:tmk_core/common/action.c ****                         if (tap_count == 0) {
 329:tmk_core/common/action.c ****                             clear_oneshot_mods();
 330:tmk_core/common/action.c ****                             unregister_mods(mods);
 331:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 332:tmk_core/common/action.c ****                             // Retain Oneshot mods
 333:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 334:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 335:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 336:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 337:tmk_core/common/action.c ****                                 unregister_mods(mods);
 338:tmk_core/common/action.c ****                             }
 339:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 340:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 341:tmk_core/common/action.c **** #        endif
 342:tmk_core/common/action.c ****                         } else {
 343:tmk_core/common/action.c ****                             clear_oneshot_mods();
 344:tmk_core/common/action.c ****                             unregister_mods(mods);
 345:tmk_core/common/action.c ****                         }
 346:tmk_core/common/action.c ****                     }
 347:tmk_core/common/action.c ****                     break;
 348:tmk_core/common/action.c **** #    endif
 349:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 350:tmk_core/common/action.c ****                     if (event.pressed) {
 351:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 352:tmk_core/common/action.c ****                             register_mods(mods);
 353:tmk_core/common/action.c ****                         }
 354:tmk_core/common/action.c ****                     } else {
 355:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 356:tmk_core/common/action.c ****                             unregister_mods(mods);
 357:tmk_core/common/action.c ****                         }
 358:tmk_core/common/action.c ****                     }
 359:tmk_core/common/action.c ****                     break;
 360:tmk_core/common/action.c ****                 default:
 361:tmk_core/common/action.c ****                     if (event.pressed) {
 362:tmk_core/common/action.c ****                         if (tap_count > 0) {
 363:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 364:tmk_core/common/action.c ****                             if (
 365:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 366:tmk_core/common/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event, fals
 367:tmk_core/common/action.c **** #        endif
 368:tmk_core/common/action.c ****                                 record->tap.interrupted) {
 369:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 370:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 371:tmk_core/common/action.c ****                                 record->tap.count = 0;
 372:tmk_core/common/action.c ****                                 register_mods(mods);
 373:tmk_core/common/action.c ****                             } else
 374:tmk_core/common/action.c **** #    endif
 375:tmk_core/common/action.c ****                             {
 376:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 377:tmk_core/common/action.c ****                                 register_code(action.key.code);
 378:tmk_core/common/action.c ****                             }
 379:tmk_core/common/action.c ****                         } else {
 380:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 381:tmk_core/common/action.c ****                             register_mods(mods);
 382:tmk_core/common/action.c ****                         }
 383:tmk_core/common/action.c ****                     } else {
 384:tmk_core/common/action.c ****                         if (tap_count > 0) {
 385:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 386:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 387:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 388:tmk_core/common/action.c ****                             } else {
 389:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 390:tmk_core/common/action.c ****                             }
 391:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 392:tmk_core/common/action.c ****                         } else {
 393:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 394:tmk_core/common/action.c ****                             unregister_mods(mods);
 395:tmk_core/common/action.c ****                         }
 396:tmk_core/common/action.c ****                     }
 397:tmk_core/common/action.c ****                     break;
 398:tmk_core/common/action.c ****             }
 399:tmk_core/common/action.c ****         } break;
 400:tmk_core/common/action.c **** #endif
 401:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 402:tmk_core/common/action.c ****         /* other HID usage */
 403:tmk_core/common/action.c ****         case ACT_USAGE:
 404:tmk_core/common/action.c ****             switch (action.usage.page) {
 405:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 406:tmk_core/common/action.c ****                     if (event.pressed) {
 407:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 408:tmk_core/common/action.c ****                     } else {
 409:tmk_core/common/action.c ****                         host_system_send(0);
 410:tmk_core/common/action.c ****                     }
 411:tmk_core/common/action.c ****                     break;
 412:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 413:tmk_core/common/action.c ****                     if (event.pressed) {
 414:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 415:tmk_core/common/action.c ****                     } else {
 416:tmk_core/common/action.c ****                         host_consumer_send(0);
 417:tmk_core/common/action.c ****                     }
 418:tmk_core/common/action.c ****                     break;
 419:tmk_core/common/action.c ****             }
 420:tmk_core/common/action.c ****             break;
 421:tmk_core/common/action.c **** #endif
 422:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 423:tmk_core/common/action.c ****         /* Mouse key */
 424:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 425:tmk_core/common/action.c ****             if (event.pressed) {
 426:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 427:tmk_core/common/action.c ****                 switch (action.key.code) {
 428:tmk_core/common/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 429:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 430:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN1);
 431:tmk_core/common/action.c ****                         break;
 432:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 433:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN2);
 434:tmk_core/common/action.c ****                         break;
 435:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 436:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN3);
 437:tmk_core/common/action.c ****                         break;
 438:tmk_core/common/action.c **** #    endif
 439:tmk_core/common/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 440:tmk_core/common/action.c ****                     case KC_MS_BTN4:
 441:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN4);
 442:tmk_core/common/action.c ****                         break;
 443:tmk_core/common/action.c ****                     case KC_MS_BTN5:
 444:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN5);
 445:tmk_core/common/action.c ****                         break;
 446:tmk_core/common/action.c **** #    endif
 447:tmk_core/common/action.c ****                     default:
 448:tmk_core/common/action.c ****                         mousekey_send();
 449:tmk_core/common/action.c ****                         break;
 450:tmk_core/common/action.c ****                 }
 451:tmk_core/common/action.c ****             } else {
 452:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 453:tmk_core/common/action.c ****                 switch (action.key.code) {
 454:tmk_core/common/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 455:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 456:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN1);
 457:tmk_core/common/action.c ****                         break;
 458:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 459:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN2);
 460:tmk_core/common/action.c ****                         break;
 461:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 462:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN3);
 463:tmk_core/common/action.c ****                         break;
 464:tmk_core/common/action.c **** #    endif
 465:tmk_core/common/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 466:tmk_core/common/action.c ****                     case KC_MS_BTN4:
 467:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN4);
 468:tmk_core/common/action.c ****                         break;
 469:tmk_core/common/action.c ****                     case KC_MS_BTN5:
 470:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN5);
 471:tmk_core/common/action.c ****                         break;
 472:tmk_core/common/action.c **** #    endif
 473:tmk_core/common/action.c ****                     default:
 474:tmk_core/common/action.c ****                         mousekey_send();
 475:tmk_core/common/action.c ****                         break;
 476:tmk_core/common/action.c ****                 }
 477:tmk_core/common/action.c ****             }
 478:tmk_core/common/action.c ****             break;
 479:tmk_core/common/action.c **** #endif
 480:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 481:tmk_core/common/action.c ****         case ACT_LAYER:
 482:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 483:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 484:tmk_core/common/action.c ****                 if (!event.pressed) {
 485:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 486:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 487:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 488:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 489:tmk_core/common/action.c ****                         case OP_BIT_AND:
 490:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 491:tmk_core/common/action.c ****                             break;
 492:tmk_core/common/action.c ****                         case OP_BIT_OR:
 493:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 494:tmk_core/common/action.c ****                             break;
 495:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 496:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 497:tmk_core/common/action.c ****                             break;
 498:tmk_core/common/action.c ****                         case OP_BIT_SET:
 499:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 500:tmk_core/common/action.c ****                             break;
 501:tmk_core/common/action.c ****                     }
 502:tmk_core/common/action.c ****                 }
 503:tmk_core/common/action.c ****             } else {
 504:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 505:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 506:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 507:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 508:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 509:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 510:tmk_core/common/action.c ****                         case OP_BIT_AND:
 511:tmk_core/common/action.c ****                             layer_and(bits | mask);
 512:tmk_core/common/action.c ****                             break;
 513:tmk_core/common/action.c ****                         case OP_BIT_OR:
 514:tmk_core/common/action.c ****                             layer_or(bits | mask);
 515:tmk_core/common/action.c ****                             break;
 516:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 517:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 518:tmk_core/common/action.c ****                             break;
 519:tmk_core/common/action.c ****                         case OP_BIT_SET:
 520:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 521:tmk_core/common/action.c ****                             break;
 522:tmk_core/common/action.c ****                     }
 523:tmk_core/common/action.c ****                 }
 524:tmk_core/common/action.c ****             }
 525:tmk_core/common/action.c ****             break;
 526:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 527:tmk_core/common/action.c ****             if (event.pressed) {
 528:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 529:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 530:tmk_core/common/action.c ****             } else {
 531:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 532:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 533:tmk_core/common/action.c ****             }
 534:tmk_core/common/action.c ****             break;
 535:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 536:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 537:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 538:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 539:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 540:tmk_core/common/action.c ****                     /* tap toggle */
 541:tmk_core/common/action.c ****                     if (event.pressed) {
 542:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 543:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 544:tmk_core/common/action.c ****                         }
 545:tmk_core/common/action.c ****                     } else {
 546:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 547:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 548:tmk_core/common/action.c ****                         }
 549:tmk_core/common/action.c ****                     }
 550:tmk_core/common/action.c ****                     break;
 551:tmk_core/common/action.c ****                 case OP_ON_OFF:
 552:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 553:tmk_core/common/action.c ****                     break;
 554:tmk_core/common/action.c ****                 case OP_OFF_ON:
 555:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 556:tmk_core/common/action.c ****                     break;
 557:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 558:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 559:tmk_core/common/action.c ****                     break;
 560:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 561:tmk_core/common/action.c ****                 case OP_ONESHOT:
 562:tmk_core/common/action.c ****                     // Oneshot modifier
 563:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 564:tmk_core/common/action.c ****                     do_release_oneshot = false;
 565:tmk_core/common/action.c ****                     if (event.pressed) {
 566:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 567:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 568:tmk_core/common/action.c ****                             reset_oneshot_layer();
 569:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 570:tmk_core/common/action.c ****                             break;
 571:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 572:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 573:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 574:tmk_core/common/action.c ****                         }
 575:tmk_core/common/action.c ****                     } else {
 576:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 577:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 578:tmk_core/common/action.c ****                             reset_oneshot_layer();
 579:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 580:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 581:tmk_core/common/action.c ****                         } else {
 582:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 583:tmk_core/common/action.c ****                         }
 584:tmk_core/common/action.c ****                     }
 585:tmk_core/common/action.c **** #            else
 586:tmk_core/common/action.c ****                     if (event.pressed) {
 587:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 588:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 589:tmk_core/common/action.c ****                     } else {
 590:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 591:tmk_core/common/action.c ****                         if (tap_count > 1) {
 592:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 593:tmk_core/common/action.c ****                         }
 594:tmk_core/common/action.c ****                     }
 595:tmk_core/common/action.c **** #            endif
 596:tmk_core/common/action.c ****                     break;
 597:tmk_core/common/action.c **** #        endif
 598:tmk_core/common/action.c ****                 default:
 599:tmk_core/common/action.c ****                     /* tap key */
 600:tmk_core/common/action.c ****                     if (event.pressed) {
 601:tmk_core/common/action.c ****                         if (tap_count > 0) {
 602:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 603:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 604:tmk_core/common/action.c ****                         } else {
 605:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 606:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 607:tmk_core/common/action.c ****                         }
 608:tmk_core/common/action.c ****                     } else {
 609:tmk_core/common/action.c ****                         if (tap_count > 0) {
 610:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 611:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 612:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 613:tmk_core/common/action.c ****                             } else {
 614:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 615:tmk_core/common/action.c ****                             }
 616:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 617:tmk_core/common/action.c ****                         } else {
 618:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 619:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 620:tmk_core/common/action.c ****                         }
 621:tmk_core/common/action.c ****                     }
 622:tmk_core/common/action.c ****                     break;
 623:tmk_core/common/action.c ****             }
 624:tmk_core/common/action.c ****             break;
 625:tmk_core/common/action.c **** #    endif
 626:tmk_core/common/action.c **** #endif
 627:tmk_core/common/action.c ****             /* Extentions */
 628:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 629:tmk_core/common/action.c ****         case ACT_MACRO:
 630:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 631:tmk_core/common/action.c ****             break;
 632:tmk_core/common/action.c **** #endif
 633:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 634:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 635:tmk_core/common/action.c ****             switch (action.swap.code) {
 636:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 637:tmk_core/common/action.c ****                     if (event.pressed) {
 638:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 639:tmk_core/common/action.c ****                     }
 640:tmk_core/common/action.c ****                     break;
 641:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 642:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 643:tmk_core/common/action.c ****                     break;
 644:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 645:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 646:tmk_core/common/action.c ****                     break;
 647:tmk_core/common/action.c ****                 case OP_SH_ON:
 648:tmk_core/common/action.c ****                     if (!event.pressed) {
 649:tmk_core/common/action.c ****                         swap_hands = true;
 650:tmk_core/common/action.c ****                     }
 651:tmk_core/common/action.c ****                     break;
 652:tmk_core/common/action.c ****                 case OP_SH_OFF:
 653:tmk_core/common/action.c ****                     if (!event.pressed) {
 654:tmk_core/common/action.c ****                         swap_hands = false;
 655:tmk_core/common/action.c ****                     }
 656:tmk_core/common/action.c ****                     break;
 657:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 658:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 659:tmk_core/common/action.c ****                     if (event.pressed) {
 660:tmk_core/common/action.c ****                         set_oneshot_swaphands();
 661:tmk_core/common/action.c ****                     } else {
 662:tmk_core/common/action.c ****                         release_oneshot_swaphands();
 663:tmk_core/common/action.c ****                     }
 664:tmk_core/common/action.c ****                     break;
 665:tmk_core/common/action.c **** #    endif
 666:tmk_core/common/action.c **** 
 667:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 668:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 669:tmk_core/common/action.c ****                     /* tap toggle */
 670:tmk_core/common/action.c **** 
 671:tmk_core/common/action.c ****                     if (event.pressed) {
 672:tmk_core/common/action.c ****                         if (swap_held) {
 673:tmk_core/common/action.c ****                             swap_held = false;
 674:tmk_core/common/action.c ****                         } else {
 675:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 676:tmk_core/common/action.c ****                         }
 677:tmk_core/common/action.c ****                     } else {
 678:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 679:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 680:tmk_core/common/action.c ****                         }
 681:tmk_core/common/action.c ****                     }
 682:tmk_core/common/action.c ****                     break;
 683:tmk_core/common/action.c ****                 default:
 684:tmk_core/common/action.c ****                     /* tap key */
 685:tmk_core/common/action.c ****                     if (tap_count > 0) {
 686:tmk_core/common/action.c ****                         if (swap_held) {
 687:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 688:tmk_core/common/action.c ****                             swap_held  = false;
 689:tmk_core/common/action.c ****                         }
 690:tmk_core/common/action.c ****                         if (event.pressed) {
 691:tmk_core/common/action.c ****                             register_code(action.swap.code);
 692:tmk_core/common/action.c ****                         } else {
 693:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 694:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 695:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 696:tmk_core/common/action.c ****                         }
 697:tmk_core/common/action.c ****                     } else {
 698:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 699:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 700:tmk_core/common/action.c ****                             swap_held  = false;
 701:tmk_core/common/action.c ****                         }
 702:tmk_core/common/action.c ****                     }
 703:tmk_core/common/action.c **** #    endif
 704:tmk_core/common/action.c ****             }
 705:tmk_core/common/action.c **** #endif
 706:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 707:tmk_core/common/action.c ****         case ACT_FUNCTION:
 708:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 709:tmk_core/common/action.c ****             break;
 710:tmk_core/common/action.c **** #endif
 711:tmk_core/common/action.c ****         default:
 712:tmk_core/common/action.c ****             break;
 713:tmk_core/common/action.c ****     }
 714:tmk_core/common/action.c **** 
 715:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 716:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 717:tmk_core/common/action.c ****     switch (action.kind.id) {
 718:tmk_core/common/action.c ****         case ACT_LAYER:
 719:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 720:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 721:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 722:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 723:tmk_core/common/action.c **** #    endif
 724:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 725:tmk_core/common/action.c ****             break;
 726:tmk_core/common/action.c ****         default:
 727:tmk_core/common/action.c ****             break;
 728:tmk_core/common/action.c ****     }
 729:tmk_core/common/action.c **** #endif
 730:tmk_core/common/action.c **** 
 731:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 732:tmk_core/common/action.c **** #    if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
 733:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 734:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 735:tmk_core/common/action.c ****     } else {
 736:tmk_core/common/action.c ****         if (event.pressed) {
 737:tmk_core/common/action.c ****             if (tap_count > 0) {
 738:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 739:tmk_core/common/action.c ****             }
 740:tmk_core/common/action.c ****         } else {
 741:tmk_core/common/action.c ****             if (tap_count > 0) {
 742:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 743:tmk_core/common/action.c ****             } else {
 744:tmk_core/common/action.c ****                 if (
 745:tmk_core/common/action.c **** #        ifdef RETRO_TAPPING_PER_KEY
 746:tmk_core/common/action.c ****                     get_retro_tapping(get_event_keycode(record->event, false), record) &&
 747:tmk_core/common/action.c **** #        endif
 748:tmk_core/common/action.c ****                     retro_tapping_counter == 2) {
 749:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 750:tmk_core/common/action.c ****                 }
 751:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 752:tmk_core/common/action.c ****             }
 753:tmk_core/common/action.c ****         }
 754:tmk_core/common/action.c ****     }
 755:tmk_core/common/action.c **** #    endif
 756:tmk_core/common/action.c **** #endif
 757:tmk_core/common/action.c **** 
 758:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 759:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 760:tmk_core/common/action.c ****     if (event.pressed && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)) 
 761:tmk_core/common/action.c ****         use_oneshot_swaphands();
 762:tmk_core/common/action.c ****     }
 763:tmk_core/common/action.c **** #    endif
 764:tmk_core/common/action.c **** #endif
 765:tmk_core/common/action.c **** 
 766:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 767:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 768:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 769:tmk_core/common/action.c ****      */
 770:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 771:tmk_core/common/action.c ****         record->event.pressed = false;
 772:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 773:tmk_core/common/action.c ****         process_record(record);
 774:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 775:tmk_core/common/action.c ****     }
 776:tmk_core/common/action.c **** #endif
 777:tmk_core/common/action.c **** }
 778:tmk_core/common/action.c **** 
 779:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 780:tmk_core/common/action.c ****  *
 781:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 782:tmk_core/common/action.c ****  */
 783:tmk_core/common/action.c **** void register_code(uint8_t code) {
 153               		.loc 1 783 0
 154               		.cfi_startproc
 155               	.LVL10:
 156 0000 CF93      		push r28
 157               	.LCFI4:
 158               		.cfi_def_cfa_offset 3
 159               		.cfi_offset 28, -2
 160               	/* prologue: function */
 161               	/* frame size = 0 */
 162               	/* stack size = 1 */
 163               	.L__stack_usage = 1
 784:tmk_core/common/action.c ****     if (code == KC_NO) {
 164               		.loc 1 784 0
 165 0002 8823      		tst r24
 166 0004 01F4      		brne .+2
 167 0006 00C0      		rjmp .L5
 168 0008 C82F      		mov r28,r24
 785:tmk_core/common/action.c ****         return;
 786:tmk_core/common/action.c ****     }
 787:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 788:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 169               		.loc 1 788 0
 170 000a 8238      		cpi r24,lo8(-126)
 171 000c 01F4      		brne .L8
 789:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 790:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 791:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 172               		.loc 1 791 0
 173 000e 0E94 0000 		call host_keyboard_leds
 174               	.LVL11:
 175 0012 81FD      		sbrc r24,1
 176 0014 00C0      		rjmp .L5
 177               	.LVL12:
 178               	.LBB82:
 179               	.LBB83:
 180               		.file 2 "tmk_core/common/action_util.h"
   1:tmk_core/common/action_util.h **** /*
   2:tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action_util.h **** 
   4:tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action_util.h **** (at your option) any later version.
   8:tmk_core/common/action_util.h **** 
   9:tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:tmk_core/common/action_util.h **** 
  14:tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action_util.h **** */
  17:tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:tmk_core/common/action_util.h **** 
  20:tmk_core/common/action_util.h **** #include <stdint.h>
  21:tmk_core/common/action_util.h **** #include "report.h"
  22:tmk_core/common/action_util.h **** 
  23:tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:tmk_core/common/action_util.h **** extern "C" {
  25:tmk_core/common/action_util.h **** #endif
  26:tmk_core/common/action_util.h **** 
  27:tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:tmk_core/common/action_util.h **** 
  29:tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:tmk_core/common/action_util.h **** 
  31:tmk_core/common/action_util.h **** /* key */
  32:tmk_core/common/action_util.h **** inline void add_key(uint8_t key) { add_key_to_report(keyboard_report, key); }
 181               		.loc 2 32 0
 182 0016 69E3      		ldi r22,lo8(57)
 183 0018 8091 0000 		lds r24,keyboard_report
 184 001c 9091 0000 		lds r25,keyboard_report+1
 185 0020 0E94 0000 		call add_key_to_report
 186               	.LVL13:
 187               	.LBE83:
 188               	.LBE82:
 792:tmk_core/common/action.c **** #    endif
 793:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 794:tmk_core/common/action.c ****         send_keyboard_report();
 189               		.loc 1 794 0
 190 0024 0E94 0000 		call send_keyboard_report
 191               	.LVL14:
 192               	.LBB84:
 193               	.LBB85:
 194               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 195               		.loc 3 187 0
 196 0028 2FEF      		ldi r18,lo8(319999)
 197 002a 81EE      		ldi r24,hi8(319999)
 198 002c 94E0      		ldi r25,hlo8(319999)
 199 002e 2150      	1:	subi r18,1
 200 0030 8040      		sbci r24,0
 201 0032 9040      		sbci r25,0
 202 0034 01F4      		brne 1b
 203 0036 00C0      		rjmp .
 204 0038 0000      		nop
 205               	.LVL15:
 206               	.LBE85:
 207               	.LBE84:
 208               	.LBB86:
 209               	.LBB87:
  33:tmk_core/common/action_util.h **** 
  34:tmk_core/common/action_util.h **** inline void del_key(uint8_t key) { del_key_from_report(keyboard_report, key); }
 210               		.loc 2 34 0
 211 003a 69E3      		ldi r22,lo8(57)
 212 003c 00C0      		rjmp .L20
 213               	.LVL16:
 214               	.L8:
 215               	.LBE87:
 216               	.LBE86:
 795:tmk_core/common/action.c ****         wait_ms(100);
 796:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 797:tmk_core/common/action.c ****         send_keyboard_report();
 798:tmk_core/common/action.c ****     }
 799:tmk_core/common/action.c **** 
 800:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 217               		.loc 1 800 0
 218 003e 8338      		cpi r24,lo8(-125)
 219 0040 01F4      		brne .L10
 801:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 802:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 220               		.loc 1 802 0
 221 0042 0E94 0000 		call host_keyboard_leds
 222               	.LVL17:
 223 0046 80FD      		sbrc r24,0
 224 0048 00C0      		rjmp .L5
 225               	.LVL18:
 226               	.LBB88:
 227               	.LBB89:
  32:tmk_core/common/action_util.h **** 
 228               		.loc 2 32 0
 229 004a 63E5      		ldi r22,lo8(83)
 230 004c 8091 0000 		lds r24,keyboard_report
 231 0050 9091 0000 		lds r25,keyboard_report+1
 232 0054 0E94 0000 		call add_key_to_report
 233               	.LVL19:
 234               	.LBE89:
 235               	.LBE88:
 803:tmk_core/common/action.c **** #    endif
 804:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 805:tmk_core/common/action.c ****         send_keyboard_report();
 236               		.loc 1 805 0
 237 0058 0E94 0000 		call send_keyboard_report
 238               	.LVL20:
 239               	.LBB90:
 240               	.LBB91:
 241               		.loc 3 187 0
 242 005c 2FEF      		ldi r18,lo8(319999)
 243 005e 81EE      		ldi r24,hi8(319999)
 244 0060 94E0      		ldi r25,hlo8(319999)
 245 0062 2150      	1:	subi r18,1
 246 0064 8040      		sbci r24,0
 247 0066 9040      		sbci r25,0
 248 0068 01F4      		brne 1b
 249 006a 00C0      		rjmp .
 250 006c 0000      		nop
 251               	.LVL21:
 252               	.LBE91:
 253               	.LBE90:
 254               	.LBB92:
 255               	.LBB93:
 256               		.loc 2 34 0
 257 006e 63E5      		ldi r22,lo8(83)
 258               	.LVL22:
 259               	.L20:
 260 0070 8091 0000 		lds r24,keyboard_report
 261 0074 9091 0000 		lds r25,keyboard_report+1
 262 0078 0E94 0000 		call del_key_from_report
 263               	.LVL23:
 264               	.L21:
 265               	/* epilogue start */
 266               	.LBE93:
 267               	.LBE92:
 806:tmk_core/common/action.c ****         wait_ms(100);
 807:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 808:tmk_core/common/action.c ****         send_keyboard_report();
 809:tmk_core/common/action.c ****     }
 810:tmk_core/common/action.c **** 
 811:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 812:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 813:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 814:tmk_core/common/action.c **** #    endif
 815:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 816:tmk_core/common/action.c ****         send_keyboard_report();
 817:tmk_core/common/action.c ****         wait_ms(100);
 818:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 819:tmk_core/common/action.c ****         send_keyboard_report();
 820:tmk_core/common/action.c ****     }
 821:tmk_core/common/action.c **** #endif
 822:tmk_core/common/action.c **** 
 823:tmk_core/common/action.c ****     else if
 824:tmk_core/common/action.c ****         IS_KEY(code) {
 825:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 826:tmk_core/common/action.c ****             if (command_proc(code)) return;
 827:tmk_core/common/action.c **** 
 828:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 829:tmk_core/common/action.c **** /* TODO: remove
 830:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 831:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 832:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 833:tmk_core/common/action.c **** 
 834:tmk_core/common/action.c ****             add_key(code);
 835:tmk_core/common/action.c ****             send_keyboard_report();
 836:tmk_core/common/action.c **** 
 837:tmk_core/common/action.c ****             set_mods(tmp_mods);
 838:tmk_core/common/action.c ****             send_keyboard_report();
 839:tmk_core/common/action.c ****             oneshot_cancel();
 840:tmk_core/common/action.c ****         } else
 841:tmk_core/common/action.c **** */
 842:tmk_core/common/action.c **** #endif
 843:tmk_core/common/action.c ****             {
 844:tmk_core/common/action.c ****                 // Force a new key press if the key is already pressed
 845:tmk_core/common/action.c ****                 // without this, keys with the same keycode, but different
 846:tmk_core/common/action.c ****                 // modifiers will be reported incorrectly, see issue #1708
 847:tmk_core/common/action.c ****                 if (is_key_pressed(keyboard_report, code)) {
 848:tmk_core/common/action.c ****                     del_key(code);
 849:tmk_core/common/action.c ****                     send_keyboard_report();
 850:tmk_core/common/action.c ****                 }
 851:tmk_core/common/action.c ****                 add_key(code);
 852:tmk_core/common/action.c ****                 send_keyboard_report();
 853:tmk_core/common/action.c ****             }
 854:tmk_core/common/action.c ****         }
 855:tmk_core/common/action.c ****     else if
 856:tmk_core/common/action.c ****         IS_MOD(code) {
 857:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 858:tmk_core/common/action.c ****             send_keyboard_report();
 859:tmk_core/common/action.c ****         }
 860:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 861:tmk_core/common/action.c ****     else if
 862:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 863:tmk_core/common/action.c ****     else if
 864:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 865:tmk_core/common/action.c **** #endif
 866:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 867:tmk_core/common/action.c ****     else if
 868:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 869:tmk_core/common/action.c ****             mousekey_on(code);
 870:tmk_core/common/action.c ****             mousekey_send();
 871:tmk_core/common/action.c ****         }
 872:tmk_core/common/action.c **** #endif
 873:tmk_core/common/action.c **** }
 268               		.loc 1 873 0
 269 007c CF91      		pop r28
 808:tmk_core/common/action.c ****     }
 270               		.loc 1 808 0
 271 007e 0C94 0000 		jmp send_keyboard_report
 272               	.LVL24:
 273               	.L10:
 811:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 274               		.loc 1 811 0
 275 0082 8438      		cpi r24,lo8(-124)
 276 0084 01F4      		brne .L11
 813:tmk_core/common/action.c **** #    endif
 277               		.loc 1 813 0
 278 0086 0E94 0000 		call host_keyboard_leds
 279               	.LVL25:
 280 008a 82FD      		sbrc r24,2
 281 008c 00C0      		rjmp .L5
 282               	.LVL26:
 283               	.LBB94:
 284               	.LBB95:
  32:tmk_core/common/action_util.h **** 
 285               		.loc 2 32 0
 286 008e 67E4      		ldi r22,lo8(71)
 287 0090 8091 0000 		lds r24,keyboard_report
 288 0094 9091 0000 		lds r25,keyboard_report+1
 289 0098 0E94 0000 		call add_key_to_report
 290               	.LVL27:
 291               	.LBE95:
 292               	.LBE94:
 816:tmk_core/common/action.c ****         wait_ms(100);
 293               		.loc 1 816 0
 294 009c 0E94 0000 		call send_keyboard_report
 295               	.LVL28:
 296               	.LBB96:
 297               	.LBB97:
 298               		.loc 3 187 0
 299 00a0 2FEF      		ldi r18,lo8(319999)
 300 00a2 81EE      		ldi r24,hi8(319999)
 301 00a4 94E0      		ldi r25,hlo8(319999)
 302 00a6 2150      	1:	subi r18,1
 303 00a8 8040      		sbci r24,0
 304 00aa 9040      		sbci r25,0
 305 00ac 01F4      		brne 1b
 306 00ae 00C0      		rjmp .
 307 00b0 0000      		nop
 308               	.LVL29:
 309               	.LBE97:
 310               	.LBE96:
 311               	.LBB98:
 312               	.LBB99:
 313               		.loc 2 34 0
 314 00b2 67E4      		ldi r22,lo8(71)
 315 00b4 00C0      		rjmp .L20
 316               	.LVL30:
 317               	.L11:
 318               	.LBE99:
 319               	.LBE98:
 824:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 320               		.loc 1 824 0
 321 00b6 8CEF      		ldi r24,lo8(-4)
 322               	.LVL31:
 323 00b8 8C0F      		add r24,r28
 324 00ba 813A      		cpi r24,lo8(-95)
 325 00bc 00F4      		brsh .L12
 847:tmk_core/common/action.c ****                     del_key(code);
 326               		.loc 1 847 0
 327 00be 6C2F      		mov r22,r28
 328 00c0 8091 0000 		lds r24,keyboard_report
 329 00c4 9091 0000 		lds r25,keyboard_report+1
 330 00c8 0E94 0000 		call is_key_pressed
 331               	.LVL32:
 332 00cc 8823      		tst r24
 333 00ce 01F0      		breq .L13
 334               	.LVL33:
 335               	.LBB100:
 336               	.LBB101:
 337               		.loc 2 34 0
 338 00d0 6C2F      		mov r22,r28
 339 00d2 8091 0000 		lds r24,keyboard_report
 340 00d6 9091 0000 		lds r25,keyboard_report+1
 341 00da 0E94 0000 		call del_key_from_report
 342               	.LVL34:
 343               	.LBE101:
 344               	.LBE100:
 849:tmk_core/common/action.c ****                 }
 345               		.loc 1 849 0
 346 00de 0E94 0000 		call send_keyboard_report
 347               	.LVL35:
 348               	.L13:
 349               	.LBB102:
 350               	.LBB103:
  32:tmk_core/common/action_util.h **** 
 351               		.loc 2 32 0
 352 00e2 6C2F      		mov r22,r28
 353 00e4 8091 0000 		lds r24,keyboard_report
 354 00e8 9091 0000 		lds r25,keyboard_report+1
 355 00ec 0E94 0000 		call add_key_to_report
 356               	.LVL36:
 357 00f0 00C0      		rjmp .L21
 358               	.L12:
 359               	.LBE103:
 360               	.LBE102:
 856:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 361               		.loc 1 856 0
 362 00f2 80E2      		ldi r24,lo8(32)
 363 00f4 8C0F      		add r24,r28
 364 00f6 8830      		cpi r24,lo8(8)
 365 00f8 00F4      		brsh .L14
 857:tmk_core/common/action.c ****             send_keyboard_report();
 366               		.loc 1 857 0
 367 00fa C770      		andi r28,lo8(7)
 368               	.LVL37:
 369 00fc 81E0      		ldi r24,lo8(1)
 370 00fe 00C0      		rjmp 2f
 371               		1:
 372 0100 880F      		lsl r24
 373               		2:
 374 0102 CA95      		dec r28
 375 0104 02F4      		brpl 1b
 376 0106 0E94 0000 		call add_mods
 377               	.LVL38:
 378 010a 00C0      		rjmp .L21
 379               	.LVL39:
 380               	.L14:
 862:tmk_core/common/action.c ****     else if
 381               		.loc 1 862 0
 382 010c EBE5      		ldi r30,lo8(91)
 383 010e EC0F      		add r30,r28
 384 0110 E330      		cpi r30,lo8(3)
 385 0112 00F4      		brsh .L15
 386 0114 F0E0      		ldi r31,0
 387 0116 E050      		subi r30,lo8(-(CSWTCH.12))
 388 0118 F040      		sbci r31,hi8(-(CSWTCH.12))
 389 011a 8081      		ld r24,Z
 390 011c 90E0      		ldi r25,0
 391               	/* epilogue start */
 392               		.loc 1 873 0
 393 011e CF91      		pop r28
 394               	.LVL40:
 862:tmk_core/common/action.c ****     else if
 395               		.loc 1 862 0
 396 0120 0C94 0000 		jmp host_system_send
 397               	.LVL41:
 398               	.L15:
 864:tmk_core/common/action.c **** #endif
 399               		.loc 1 864 0
 400 0124 E8E5      		ldi r30,lo8(88)
 401 0126 EC0F      		add r30,r28
 402 0128 E731      		cpi r30,lo8(23)
 403 012a 00F4      		brsh .L16
 404 012c F0E0      		ldi r31,0
 405 012e EE0F      		lsl r30
 406 0130 FF1F      		rol r31
 407 0132 E050      		subi r30,lo8(-(CSWTCH.14))
 408 0134 F040      		sbci r31,hi8(-(CSWTCH.14))
 409 0136 8081      		ld r24,Z
 410 0138 9181      		ldd r25,Z+1
 411               	/* epilogue start */
 412               		.loc 1 873 0
 413 013a CF91      		pop r28
 414               	.LVL42:
 864:tmk_core/common/action.c **** #endif
 415               		.loc 1 864 0
 416 013c 0C94 0000 		jmp host_consumer_send
 417               	.LVL43:
 418               	.L16:
 868:tmk_core/common/action.c ****             mousekey_on(code);
 419               		.loc 1 868 0
 420 0140 C03F      		cpi r28,lo8(-16)
 421 0142 00F0      		brlo .L5
 869:tmk_core/common/action.c ****             mousekey_send();
 422               		.loc 1 869 0
 423 0144 8C2F      		mov r24,r28
 424 0146 0E94 0000 		call mousekey_on
 425               	.LVL44:
 426               	/* epilogue start */
 427               		.loc 1 873 0
 428 014a CF91      		pop r28
 429               	.LVL45:
 870:tmk_core/common/action.c ****         }
 430               		.loc 1 870 0
 431 014c 0C94 0000 		jmp mousekey_send
 432               	.LVL46:
 433               	.L5:
 434               	/* epilogue start */
 435               		.loc 1 873 0
 436 0150 CF91      		pop r28
 437 0152 0895      		ret
 438               		.cfi_endproc
 439               	.LFE116:
 441               		.section	.text.unregister_code,"ax",@progbits
 442               	.global	unregister_code
 444               	unregister_code:
 445               	.LFB117:
 874:tmk_core/common/action.c **** 
 875:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 876:tmk_core/common/action.c ****  *
 877:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 878:tmk_core/common/action.c ****  */
 879:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 446               		.loc 1 879 0
 447               		.cfi_startproc
 448               	.LVL47:
 449               	/* prologue: function */
 450               	/* frame size = 0 */
 451               	/* stack size = 0 */
 452               	.L__stack_usage = 0
 880:tmk_core/common/action.c ****     if (code == KC_NO) {
 453               		.loc 1 880 0
 454 0000 8823      		tst r24
 455 0002 01F4      		brne .+2
 456 0004 00C0      		rjmp .L23
 881:tmk_core/common/action.c ****         return;
 882:tmk_core/common/action.c ****     }
 883:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 884:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 457               		.loc 1 884 0
 458 0006 8238      		cpi r24,lo8(-126)
 459 0008 01F4      		brne .L26
 885:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 886:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 887:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 460               		.loc 1 887 0
 461 000a 0E94 0000 		call host_keyboard_leds
 462               	.LVL48:
 463 000e 81FF      		sbrs r24,1
 464 0010 00C0      		rjmp .L23
 465               	.LVL49:
 466               	.LBB104:
 467               	.LBB105:
  32:tmk_core/common/action_util.h **** 
 468               		.loc 2 32 0
 469 0012 69E3      		ldi r22,lo8(57)
 470 0014 8091 0000 		lds r24,keyboard_report
 471 0018 9091 0000 		lds r25,keyboard_report+1
 472 001c 0E94 0000 		call add_key_to_report
 473               	.LVL50:
 474               	.LBE105:
 475               	.LBE104:
 888:tmk_core/common/action.c **** #    endif
 889:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 890:tmk_core/common/action.c ****         send_keyboard_report();
 476               		.loc 1 890 0
 477 0020 0E94 0000 		call send_keyboard_report
 478               	.LVL51:
 479               	.LBB106:
 480               	.LBB107:
 481               		.loc 2 34 0
 482 0024 69E3      		ldi r22,lo8(57)
 483 0026 00C0      		rjmp .L43
 484               	.LVL52:
 485               	.L26:
 486               	.LBE107:
 487               	.LBE106:
 891:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 892:tmk_core/common/action.c ****         send_keyboard_report();
 893:tmk_core/common/action.c ****     }
 894:tmk_core/common/action.c **** 
 895:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 488               		.loc 1 895 0
 489 0028 8338      		cpi r24,lo8(-125)
 490 002a 01F4      		brne .L28
 896:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 897:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 491               		.loc 1 897 0
 492 002c 0E94 0000 		call host_keyboard_leds
 493               	.LVL53:
 494 0030 80FF      		sbrs r24,0
 495 0032 00C0      		rjmp .L23
 496               	.LVL54:
 497               	.LBB108:
 498               	.LBB109:
  32:tmk_core/common/action_util.h **** 
 499               		.loc 2 32 0
 500 0034 63E5      		ldi r22,lo8(83)
 501 0036 8091 0000 		lds r24,keyboard_report
 502 003a 9091 0000 		lds r25,keyboard_report+1
 503 003e 0E94 0000 		call add_key_to_report
 504               	.LVL55:
 505               	.LBE109:
 506               	.LBE108:
 898:tmk_core/common/action.c **** #    endif
 899:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 900:tmk_core/common/action.c ****         send_keyboard_report();
 507               		.loc 1 900 0
 508 0042 0E94 0000 		call send_keyboard_report
 509               	.LVL56:
 510               	.LBB110:
 511               	.LBB111:
 512               		.loc 2 34 0
 513 0046 63E5      		ldi r22,lo8(83)
 514               	.LVL57:
 515               	.L43:
 516 0048 8091 0000 		lds r24,keyboard_report
 517 004c 9091 0000 		lds r25,keyboard_report+1
 518 0050 0E94 0000 		call del_key_from_report
 519               	.LVL58:
 520               	.L44:
 521               	.LBE111:
 522               	.LBE110:
 901:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 902:tmk_core/common/action.c ****         send_keyboard_report();
 523               		.loc 1 902 0
 524 0054 0C94 0000 		jmp send_keyboard_report
 525               	.LVL59:
 526               	.L28:
 903:tmk_core/common/action.c ****     }
 904:tmk_core/common/action.c **** 
 905:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 527               		.loc 1 905 0
 528 0058 8438      		cpi r24,lo8(-124)
 529 005a 01F4      		brne .L29
 906:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 907:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 530               		.loc 1 907 0
 531 005c 0E94 0000 		call host_keyboard_leds
 532               	.LVL60:
 533 0060 82FF      		sbrs r24,2
 534 0062 00C0      		rjmp .L23
 535               	.LVL61:
 536               	.LBB112:
 537               	.LBB113:
  32:tmk_core/common/action_util.h **** 
 538               		.loc 2 32 0
 539 0064 67E4      		ldi r22,lo8(71)
 540 0066 8091 0000 		lds r24,keyboard_report
 541 006a 9091 0000 		lds r25,keyboard_report+1
 542 006e 0E94 0000 		call add_key_to_report
 543               	.LVL62:
 544               	.LBE113:
 545               	.LBE112:
 908:tmk_core/common/action.c **** #    endif
 909:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 910:tmk_core/common/action.c ****         send_keyboard_report();
 546               		.loc 1 910 0
 547 0072 0E94 0000 		call send_keyboard_report
 548               	.LVL63:
 549               	.LBB114:
 550               	.LBB115:
 551               		.loc 2 34 0
 552 0076 67E4      		ldi r22,lo8(71)
 553 0078 00C0      		rjmp .L43
 554               	.LVL64:
 555               	.L29:
 556               	.LBE115:
 557               	.LBE114:
 911:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 912:tmk_core/common/action.c ****         send_keyboard_report();
 913:tmk_core/common/action.c ****     }
 914:tmk_core/common/action.c **** #endif
 915:tmk_core/common/action.c **** 
 916:tmk_core/common/action.c ****     else if
 917:tmk_core/common/action.c ****         IS_KEY(code) {
 558               		.loc 1 917 0
 559 007a 9CEF      		ldi r25,lo8(-4)
 560 007c 980F      		add r25,r24
 561 007e 913A      		cpi r25,lo8(-95)
 562 0080 00F4      		brsh .L30
 563               	.LVL65:
 564               	.LBB116:
 565               	.LBB117:
 566               		.loc 2 34 0
 567 0082 682F      		mov r22,r24
 568 0084 00C0      		rjmp .L43
 569               	.LVL66:
 570               	.L30:
 571               	.LBE117:
 572               	.LBE116:
 918:tmk_core/common/action.c ****             del_key(code);
 919:tmk_core/common/action.c ****             send_keyboard_report();
 920:tmk_core/common/action.c ****         }
 921:tmk_core/common/action.c ****     else if
 922:tmk_core/common/action.c ****         IS_MOD(code) {
 573               		.loc 1 922 0
 574 0086 90E2      		ldi r25,lo8(32)
 575 0088 980F      		add r25,r24
 576 008a 9830      		cpi r25,lo8(8)
 577 008c 00F4      		brsh .L31
 923:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 578               		.loc 1 923 0
 579 008e 8770      		andi r24,lo8(7)
 580               	.LVL67:
 581 0090 91E0      		ldi r25,lo8(1)
 582 0092 00C0      		rjmp 2f
 583               		1:
 584 0094 990F      		lsl r25
 585               		2:
 586 0096 8A95      		dec r24
 587 0098 02F4      		brpl 1b
 588 009a 892F      		mov r24,r25
 589 009c 0E94 0000 		call del_mods
 590               	.LVL68:
 591 00a0 00C0      		rjmp .L44
 592               	.LVL69:
 593               	.L31:
 924:tmk_core/common/action.c ****             send_keyboard_report();
 925:tmk_core/common/action.c ****         }
 926:tmk_core/common/action.c ****     else if
 927:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 594               		.loc 1 927 0
 595 00a2 9BE5      		ldi r25,lo8(91)
 596 00a4 980F      		add r25,r24
 597 00a6 9330      		cpi r25,lo8(3)
 598 00a8 00F4      		brsh .L32
 599               		.loc 1 927 0 is_stmt 0 discriminator 1
 600 00aa 80E0      		ldi r24,0
 601 00ac 90E0      		ldi r25,0
 602               	.LVL70:
 603 00ae 0C94 0000 		jmp host_system_send
 604               	.LVL71:
 605               	.L32:
 928:tmk_core/common/action.c ****     else if
 929:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 606               		.loc 1 929 0 is_stmt 1
 607 00b2 98E5      		ldi r25,lo8(88)
 608 00b4 980F      		add r25,r24
 609 00b6 9731      		cpi r25,lo8(23)
 610 00b8 00F4      		brsh .L33
 611               		.loc 1 929 0 is_stmt 0 discriminator 1
 612 00ba 80E0      		ldi r24,0
 613 00bc 90E0      		ldi r25,0
 614               	.LVL72:
 615 00be 0C94 0000 		jmp host_consumer_send
 616               	.LVL73:
 617               	.L33:
 930:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 931:tmk_core/common/action.c ****     else if
 932:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 618               		.loc 1 932 0 is_stmt 1
 619 00c2 803F      		cpi r24,lo8(-16)
 620 00c4 00F0      		brlo .L23
 933:tmk_core/common/action.c ****             mousekey_off(code);
 621               		.loc 1 933 0
 622 00c6 0E94 0000 		call mousekey_off
 623               	.LVL74:
 934:tmk_core/common/action.c ****             mousekey_send();
 624               		.loc 1 934 0
 625 00ca 0C94 0000 		jmp mousekey_send
 626               	.LVL75:
 627               	.L23:
 628 00ce 0895      		ret
 629               		.cfi_endproc
 630               	.LFE117:
 632               		.section	.text.tap_code,"ax",@progbits
 633               	.global	tap_code
 635               	tap_code:
 636               	.LFB118:
 935:tmk_core/common/action.c ****         }
 936:tmk_core/common/action.c **** #endif
 937:tmk_core/common/action.c **** }
 938:tmk_core/common/action.c **** 
 939:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 940:tmk_core/common/action.c ****  *
 941:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 942:tmk_core/common/action.c ****  */
 943:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 637               		.loc 1 943 0
 638               		.cfi_startproc
 639               	.LVL76:
 640 0000 CF93      		push r28
 641               	.LCFI5:
 642               		.cfi_def_cfa_offset 3
 643               		.cfi_offset 28, -2
 644               	/* prologue: function */
 645               	/* frame size = 0 */
 646               	/* stack size = 1 */
 647               	.L__stack_usage = 1
 648 0002 C82F      		mov r28,r24
 944:tmk_core/common/action.c ****     register_code(code);
 649               		.loc 1 944 0
 650 0004 0E94 0000 		call register_code
 651               	.LVL77:
 945:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 652               		.loc 1 945 0
 653 0008 C933      		cpi r28,lo8(57)
 654 000a 01F4      		brne .L47
 655               	.LVL78:
 656               	.LBB118:
 657               	.LBB119:
 658               		.loc 3 187 0
 659 000c 2FEF      		ldi r18,lo8(255999)
 660 000e 87EE      		ldi r24,hi8(255999)
 661 0010 93E0      		ldi r25,hlo8(255999)
 662 0012 2150      	1:	subi r18,1
 663 0014 8040      		sbci r24,0
 664 0016 9040      		sbci r25,0
 665 0018 01F4      		brne 1b
 666 001a 00C0      		rjmp .
 667 001c 0000      		nop
 668               	.LVL79:
 669               	.L47:
 670               	.LBE119:
 671               	.LBE118:
 946:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 947:tmk_core/common/action.c ****     } else {
 948:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 949:tmk_core/common/action.c ****     }
 950:tmk_core/common/action.c ****     unregister_code(code);
 672               		.loc 1 950 0
 673 001e 8C2F      		mov r24,r28
 674               	/* epilogue start */
 951:tmk_core/common/action.c **** }
 675               		.loc 1 951 0
 676 0020 CF91      		pop r28
 677               	.LVL80:
 950:tmk_core/common/action.c **** }
 678               		.loc 1 950 0
 679 0022 0C94 0000 		jmp unregister_code
 680               	.LVL81:
 681               		.cfi_endproc
 682               	.LFE118:
 684               		.section	.text.register_mods,"ax",@progbits
 685               	.global	register_mods
 687               	register_mods:
 688               	.LFB119:
 952:tmk_core/common/action.c **** 
 953:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 954:tmk_core/common/action.c ****  *
 955:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 956:tmk_core/common/action.c ****  */
 957:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 689               		.loc 1 957 0
 690               		.cfi_startproc
 691               	.LVL82:
 692               	/* prologue: function */
 693               	/* frame size = 0 */
 694               	/* stack size = 0 */
 695               	.L__stack_usage = 0
 958:tmk_core/common/action.c ****     if (mods) {
 696               		.loc 1 958 0
 697 0000 8823      		tst r24
 698 0002 01F0      		breq .L48
 959:tmk_core/common/action.c ****         add_mods(mods);
 699               		.loc 1 959 0
 700 0004 0E94 0000 		call add_mods
 701               	.LVL83:
 960:tmk_core/common/action.c ****         send_keyboard_report();
 702               		.loc 1 960 0
 703 0008 0C94 0000 		jmp send_keyboard_report
 704               	.LVL84:
 705               	.L48:
 706 000c 0895      		ret
 707               		.cfi_endproc
 708               	.LFE119:
 710               		.section	.text.unregister_mods,"ax",@progbits
 711               	.global	unregister_mods
 713               	unregister_mods:
 714               	.LFB120:
 961:tmk_core/common/action.c ****     }
 962:tmk_core/common/action.c **** }
 963:tmk_core/common/action.c **** 
 964:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 965:tmk_core/common/action.c ****  *
 966:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 967:tmk_core/common/action.c ****  */
 968:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 715               		.loc 1 968 0
 716               		.cfi_startproc
 717               	.LVL85:
 718               	/* prologue: function */
 719               	/* frame size = 0 */
 720               	/* stack size = 0 */
 721               	.L__stack_usage = 0
 969:tmk_core/common/action.c ****     if (mods) {
 722               		.loc 1 969 0
 723 0000 8823      		tst r24
 724 0002 01F0      		breq .L50
 970:tmk_core/common/action.c ****         del_mods(mods);
 725               		.loc 1 970 0
 726 0004 0E94 0000 		call del_mods
 727               	.LVL86:
 971:tmk_core/common/action.c ****         send_keyboard_report();
 728               		.loc 1 971 0
 729 0008 0C94 0000 		jmp send_keyboard_report
 730               	.LVL87:
 731               	.L50:
 732 000c 0895      		ret
 733               		.cfi_endproc
 734               	.LFE120:
 736               		.section	.text.process_action,"ax",@progbits
 737               	.global	process_action
 739               	process_action:
 740               	.LFB115:
 248:tmk_core/common/action.c ****     keyevent_t event = record->event;
 741               		.loc 1 248 0
 742               		.cfi_startproc
 743               	.LVL88:
 744 0000 CF92      		push r12
 745               	.LCFI6:
 746               		.cfi_def_cfa_offset 3
 747               		.cfi_offset 12, -2
 748 0002 DF92      		push r13
 749               	.LCFI7:
 750               		.cfi_def_cfa_offset 4
 751               		.cfi_offset 13, -3
 752 0004 EF92      		push r14
 753               	.LCFI8:
 754               		.cfi_def_cfa_offset 5
 755               		.cfi_offset 14, -4
 756 0006 FF92      		push r15
 757               	.LCFI9:
 758               		.cfi_def_cfa_offset 6
 759               		.cfi_offset 15, -5
 760 0008 0F93      		push r16
 761               	.LCFI10:
 762               		.cfi_def_cfa_offset 7
 763               		.cfi_offset 16, -6
 764 000a 1F93      		push r17
 765               	.LCFI11:
 766               		.cfi_def_cfa_offset 8
 767               		.cfi_offset 17, -7
 768 000c CF93      		push r28
 769               	.LCFI12:
 770               		.cfi_def_cfa_offset 9
 771               		.cfi_offset 28, -8
 772 000e DF93      		push r29
 773               	.LCFI13:
 774               		.cfi_def_cfa_offset 10
 775               		.cfi_offset 29, -9
 776               	/* prologue: function */
 777               	/* frame size = 0 */
 778               	/* stack size = 8 */
 779               	.L__stack_usage = 8
 780 0010 7C01      		movw r14,r24
 781 0012 062F      		mov r16,r22
 782 0014 C72F      		mov r28,r23
 783               	.LVL89:
 251:tmk_core/common/action.c **** #endif
 784               		.loc 1 251 0
 785 0016 FC01      		movw r30,r24
 786 0018 1581      		ldd r17,Z+5
 787 001a 1295      		swap r17
 788 001c 1F70      		andi r17,lo8(15)
 789               	.LVL90:
 254:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 790               		.loc 1 254 0
 791 001e D281      		ldd r29,Z+2
 792 0020 D111      		cpse r29,__zero_reg__
 256:tmk_core/common/action.c ****     }
 793               		.loc 1 256 0
 794 0022 0E94 0000 		call clear_weak_mods
 795               	.LVL91:
 796               	.L53:
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 797               		.loc 1 262 0
 798 0026 0E94 0000 		call is_oneshot_layer_active
 799               	.LVL92:
 800 002a 8823      		tst r24
 801 002c 01F0      		breq .L139
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 802               		.loc 1 262 0 is_stmt 0 discriminator 1
 803 002e DD23      		tst r29
 804 0030 01F0      		breq .L139
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 805               		.loc 1 262 0 discriminator 2
 806 0032 8C2F      		mov r24,r28
 807 0034 807F      		andi r24,lo8(-16)
 808 0036 8034      		cpi r24,lo8(64)
 809 0038 01F0      		breq .L55
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 810               		.loc 1 262 0 discriminator 3
 811 003a 80E2      		ldi r24,lo8(32)
 812               	.LVL93:
 813 003c 800F      		add r24,r16
 814 003e 8830      		cpi r24,lo8(8)
 815 0040 00F0      		brlo .L139
 816               	.L55:
 267:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 817               		.loc 1 267 0 is_stmt 1
 818 0042 82E0      		ldi r24,lo8(2)
 819 0044 0E94 0000 		call clear_oneshot_layer_state
 820               	.LVL94:
 268:tmk_core/common/action.c ****     }
 821               		.loc 1 268 0
 822 0048 0E94 0000 		call is_oneshot_layer_active
 823               	.LVL95:
 824 004c 91E0      		ldi r25,lo8(1)
 825 004e D82E      		mov r13,r24
 826 0050 D926      		eor r13,r25
 827               	.LVL96:
 828 0052 00C0      		rjmp .L54
 829               	.LVL97:
 830               	.L139:
 260:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 831               		.loc 1 260 0
 832 0054 D12C      		mov r13,__zero_reg__
 833               	.LVL98:
 834               	.L54:
 272:tmk_core/common/action.c ****         /* Key and Mods */
 835               		.loc 1 272 0
 836 0056 CC2E      		mov r12,r28
 837 0058 C294      		swap r12
 838 005a 8FE0      		ldi r24,lo8(15)
 839 005c C822      		and r12,r24
 840 005e 8C2D      		mov r24,r12
 841 0060 90E0      		ldi r25,0
 842 0062 FC01      		movw r30,r24
 843 0064 E050      		subi r30,lo8(-(gs(.L58)))
 844 0066 F040      		sbci r31,hi8(-(gs(.L58)))
 845 0068 0C94 0000 		jmp __tablejump2__
 846               		.section	.progmem.gcc_sw_table.process_action,"a",@progbits
 847               		.p2align	1
 848               	.L58:
 849 0000 0000      		.word gs(.L57)
 850 0002 0000      		.word gs(.L57)
 851 0004 0000      		.word gs(.L59)
 852 0006 0000      		.word gs(.L59)
 853 0008 0000      		.word gs(.L60)
 854 000a 0000      		.word gs(.L61)
 855 000c 0000      		.word gs(.L56)
 856 000e 0000      		.word gs(.L56)
 857 0010 0000      		.word gs(.L62)
 858 0012 0000      		.word gs(.L63)
 859 0014 0000      		.word gs(.L64)
 860 0016 0000      		.word gs(.L64)
 861 0018 0000      		.word gs(.L65)
 862 001a 0000      		.word gs(.L56)
 863 001c 0000      		.word gs(.L56)
 864 001e 0000      		.word gs(.L66)
 865               		.section	.text.process_action
 866               	.L57:
 867               	.LBB120:
 276:tmk_core/common/action.c ****             if (event.pressed) {
 868               		.loc 1 276 0
 869 006c 8C2F      		mov r24,r28
 870 006e 807F      		andi r24,lo8(-16)
 871 0070 CF70      		andi r28,lo8(15)
 872               	.LVL99:
 873 0072 8823      		tst r24
 874 0074 01F0      		breq .L68
 276:tmk_core/common/action.c ****             if (event.pressed) {
 875               		.loc 1 276 0 is_stmt 0 discriminator 2
 876 0076 C295      		swap r28
 877 0078 C07F      		andi r28,lo8(-16)
 878               	.L68:
 879               	.LVL100:
 277:tmk_core/common/action.c ****                 if (mods) {
 880               		.loc 1 277 0 is_stmt 1 discriminator 4
 881 007a DD23      		tst r29
 882 007c 01F0      		breq .L69
 278:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 883               		.loc 1 278 0
 884 007e CC23      		tst r28
 885 0080 01F4      		brne .+2
 886 0082 00C0      		rjmp .L167
 279:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 887               		.loc 1 279 0
 888 0084 80E2      		ldi r24,lo8(32)
 889 0086 800F      		add r24,r16
 890 0088 8830      		cpi r24,lo8(8)
 891 008a 00F0      		brlo .L71
 279:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 892               		.loc 1 279 0 is_stmt 0 discriminator 1
 893 008c 0111      		cpse r16,__zero_reg__
 894 008e 00C0      		rjmp .L72
 895               	.L71:
 283:tmk_core/common/action.c ****                     } else {
 896               		.loc 1 283 0 is_stmt 1
 897 0090 8C2F      		mov r24,r28
 898 0092 0E94 0000 		call add_mods
 899               	.LVL101:
 900 0096 00C0      		rjmp .L73
 901               	.L72:
 285:tmk_core/common/action.c ****                     }
 902               		.loc 1 285 0
 903 0098 8C2F      		mov r24,r28
 904 009a 0E94 0000 		call add_weak_mods
 905               	.LVL102:
 906               	.L73:
 287:tmk_core/common/action.c ****                 }
 907               		.loc 1 287 0
 908 009e 0E94 0000 		call send_keyboard_report
 909               	.LVL103:
 910 00a2 00C0      		rjmp .L167
 911               	.L69:
 291:tmk_core/common/action.c ****                 if (mods) {
 912               		.loc 1 291 0
 913 00a4 802F      		mov r24,r16
 914 00a6 0E94 0000 		call unregister_code
 915               	.LVL104:
 292:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 916               		.loc 1 292 0
 917 00aa CC23      		tst r28
 918 00ac 01F4      		brne .+2
 919 00ae 00C0      		rjmp .L56
 293:tmk_core/common/action.c ****                         del_mods(mods);
 920               		.loc 1 293 0
 921 00b0 80E2      		ldi r24,lo8(32)
 922 00b2 800F      		add r24,r16
 923 00b4 8830      		cpi r24,lo8(8)
 924 00b6 00F0      		brlo .L75
 293:tmk_core/common/action.c ****                         del_mods(mods);
 925               		.loc 1 293 0 is_stmt 0 discriminator 1
 926 00b8 0111      		cpse r16,__zero_reg__
 927 00ba 00C0      		rjmp .L76
 928               	.L75:
 294:tmk_core/common/action.c ****                     } else {
 929               		.loc 1 294 0 is_stmt 1
 930 00bc 8C2F      		mov r24,r28
 931 00be 0E94 0000 		call del_mods
 932               	.LVL105:
 933 00c2 00C0      		rjmp .L77
 934               	.L76:
 296:tmk_core/common/action.c ****                     }
 935               		.loc 1 296 0
 936 00c4 8C2F      		mov r24,r28
 937 00c6 0E94 0000 		call del_weak_mods
 938               	.LVL106:
 939               	.L77:
 298:tmk_core/common/action.c ****                 }
 940               		.loc 1 298 0
 941 00ca 0E94 0000 		call send_keyboard_report
 942               	.LVL107:
 943 00ce 00C0      		rjmp .L56
 944               	.LVL108:
 945               	.L59:
 946               	.LBE120:
 947               	.LBB121:
 305:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 948               		.loc 1 305 0
 949 00d0 8C2F      		mov r24,r28
 950 00d2 807F      		andi r24,lo8(-16)
 951 00d4 CF70      		andi r28,lo8(15)
 952               	.LVL109:
 953 00d6 8032      		cpi r24,lo8(32)
 954 00d8 01F0      		breq .L79
 305:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 955               		.loc 1 305 0 is_stmt 0 discriminator 2
 956 00da C295      		swap r28
 957 00dc C07F      		andi r28,lo8(-16)
 958               	.L79:
 959               	.LVL110:
 306:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 960               		.loc 1 306 0 is_stmt 1 discriminator 4
 961 00de 0023      		tst r16
 962 00e0 01F0      		breq .L81
 963 00e2 0130      		cpi r16,lo8(1)
 964 00e4 01F0      		breq .L82
 965 00e6 00C0      		rjmp .L175
 966               	.L81:
 310:tmk_core/common/action.c ****                         if (tap_count == 0) {
 967               		.loc 1 310 0
 968 00e8 DD23      		tst r29
 969 00ea 01F0      		breq .L83
 311:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 970               		.loc 1 311 0
 971 00ec 1123      		tst r17
 972 00ee 01F0      		breq .L85
 314:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 973               		.loc 1 314 0
 974 00f0 1130      		cpi r17,lo8(1)
 975 00f2 01F4      		brne .L85
 316:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 976               		.loc 1 316 0
 977 00f4 0E94 0000 		call get_oneshot_mods
 978               	.LVL111:
 979 00f8 8C2B      		or r24,r28
 980 00fa 0E94 0000 		call set_oneshot_mods
 981               	.LVL112:
 982 00fe 00C0      		rjmp .L56
 983               	.L85:
 325:tmk_core/common/action.c ****                         }
 984               		.loc 1 325 0
 985 0100 0E94 0000 		call get_oneshot_mods
 986               	.LVL113:
 987 0104 8C2B      		or r24,r28
 988 0106 00C0      		rjmp .L168
 989               	.L83:
 328:tmk_core/common/action.c ****                             clear_oneshot_mods();
 990               		.loc 1 328 0
 991 0108 1123      		tst r17
 992 010a 01F0      		breq .L173
 331:tmk_core/common/action.c ****                             // Retain Oneshot mods
 993               		.loc 1 331 0
 994 010c 1130      		cpi r17,lo8(1)
 995 010e 01F4      		brne .+2
 996 0110 00C0      		rjmp .L56
 997               	.L173:
 343:tmk_core/common/action.c ****                             unregister_mods(mods);
 998               		.loc 1 343 0
 999 0112 0E94 0000 		call clear_oneshot_mods
 1000               	.LVL114:
 1001 0116 00C0      		rjmp .L92
 1002               	.L82:
 350:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1003               		.loc 1 350 0
 1004 0118 DD23      		tst r29
 1005 011a 01F0      		breq .L88
 351:tmk_core/common/action.c ****                             register_mods(mods);
 1006               		.loc 1 351 0
 1007 011c 1630      		cpi r17,lo8(6)
 1008 011e 00F0      		brlo .+2
 1009 0120 00C0      		rjmp .L56
 1010 0122 00C0      		rjmp .L169
 1011               	.L88:
 355:tmk_core/common/action.c ****                             unregister_mods(mods);
 1012               		.loc 1 355 0
 1013 0124 1530      		cpi r17,lo8(5)
 1014 0126 00F0      		brlo .+2
 1015 0128 00C0      		rjmp .L56
 1016 012a 00C0      		rjmp .L92
 1017               	.L175:
 361:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1018               		.loc 1 361 0
 1019 012c DD23      		tst r29
 1020 012e 01F0      		breq .L89
 362:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1021               		.loc 1 362 0
 1022 0130 1123      		tst r17
 1023 0132 01F0      		breq .L169
 368:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 1024               		.loc 1 368 0
 1025 0134 F701      		movw r30,r14
 1026 0136 8581      		ldd r24,Z+5
 364:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1027               		.loc 1 364 0
 1028 0138 80FF      		sbrs r24,0
 1029 013a 00C0      		rjmp .L167
 371:tmk_core/common/action.c ****                                 register_mods(mods);
 1030               		.loc 1 371 0
 1031 013c 8F70      		andi r24,lo8(15)
 1032 013e 8583      		std Z+5,r24
 1033               	.L169:
 372:tmk_core/common/action.c ****                             } else
 1034               		.loc 1 372 0
 1035 0140 8C2F      		mov r24,r28
 1036               	.L168:
 1037 0142 0E94 0000 		call register_mods
 1038               	.LVL115:
 1039 0146 00C0      		rjmp .L56
 1040               	.L89:
 384:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1041               		.loc 1 384 0
 1042 0148 1123      		tst r17
 1043 014a 01F0      		breq .L92
 386:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1044               		.loc 1 386 0
 1045 014c 0933      		cpi r16,lo8(57)
 1046 014e 01F0      		breq .+2
 1047 0150 00C0      		rjmp .L131
 1048               	.LVL116:
 1049               	.LBB122:
 1050               	.LBB123:
 1051               		.loc 3 187 0
 1052 0152 FFEF      		ldi r31,lo8(255999)
 1053 0154 27EE      		ldi r18,hi8(255999)
 1054 0156 83E0      		ldi r24,hlo8(255999)
 1055 0158 F150      	1:	subi r31,1
 1056 015a 2040      		sbci r18,0
 1057 015c 8040      		sbci r24,0
 1058 015e 01F4      		brne 1b
 1059 0160 00C0      		rjmp .L174
 1060               	.LVL117:
 1061               	.L92:
 1062               	.LBE123:
 1063               	.LBE122:
 394:tmk_core/common/action.c ****                         }
 1064               		.loc 1 394 0
 1065 0162 8C2F      		mov r24,r28
 1066 0164 0E94 0000 		call unregister_mods
 1067               	.LVL118:
 1068 0168 00C0      		rjmp .L56
 1069               	.LVL119:
 1070               	.L60:
 1071               	.LBE121:
 404:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1072               		.loc 1 404 0
 1073 016a 8C2F      		mov r24,r28
 1074 016c 8695      		lsr r24
 1075 016e 8695      		lsr r24
 1076 0170 8370      		andi r24,lo8(3)
 1077 0172 01F0      		breq .L95
 1078 0174 8130      		cpi r24,lo8(1)
 1079 0176 01F0      		breq .L96
 1080 0178 00C0      		rjmp .L56
 1081               	.L95:
 406:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1082               		.loc 1 406 0
 1083 017a DD23      		tst r29
 1084 017c 01F0      		breq .L97
 407:tmk_core/common/action.c ****                     } else {
 1085               		.loc 1 407 0
 1086 017e 802F      		mov r24,r16
 1087 0180 9C2F      		mov r25,r28
 1088 0182 9370      		andi r25,lo8(3)
 1089 0184 00C0      		rjmp .L170
 1090               	.L97:
 409:tmk_core/common/action.c ****                     }
 1091               		.loc 1 409 0
 1092 0186 80E0      		ldi r24,0
 1093 0188 90E0      		ldi r25,0
 1094               	.L170:
 1095 018a 0E94 0000 		call host_system_send
 1096               	.LVL120:
 1097 018e 00C0      		rjmp .L132
 1098               	.L96:
 413:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1099               		.loc 1 413 0
 1100 0190 DD23      		tst r29
 1101 0192 01F0      		breq .L99
 414:tmk_core/common/action.c ****                     } else {
 1102               		.loc 1 414 0
 1103 0194 802F      		mov r24,r16
 1104 0196 9C2F      		mov r25,r28
 1105 0198 9370      		andi r25,lo8(3)
 1106 019a 00C0      		rjmp .L171
 1107               	.L99:
 416:tmk_core/common/action.c ****                     }
 1108               		.loc 1 416 0
 1109 019c 80E0      		ldi r24,0
 1110 019e 90E0      		ldi r25,0
 1111               	.L171:
 1112 01a0 0E94 0000 		call host_consumer_send
 1113               	.LVL121:
 1114 01a4 00C0      		rjmp .L132
 1115               	.L61:
 426:tmk_core/common/action.c ****                 switch (action.key.code) {
 1116               		.loc 1 426 0
 1117 01a6 802F      		mov r24,r16
 425:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 1118               		.loc 1 425 0
 1119 01a8 DD23      		tst r29
 1120 01aa 01F0      		breq .L100
 426:tmk_core/common/action.c ****                 switch (action.key.code) {
 1121               		.loc 1 426 0
 1122 01ac 0E94 0000 		call mousekey_on
 1123               	.LVL122:
 1124 01b0 00C0      		rjmp .L172
 1125               	.L100:
 452:tmk_core/common/action.c ****                 switch (action.key.code) {
 1126               		.loc 1 452 0
 1127 01b2 0E94 0000 		call mousekey_off
 1128               	.LVL123:
 1129               	.L172:
 474:tmk_core/common/action.c ****                         break;
 1130               		.loc 1 474 0
 1131 01b6 0E94 0000 		call mousekey_send
 1132               	.LVL124:
 475:tmk_core/common/action.c ****                 }
 1133               		.loc 1 475 0
 1134 01ba 00C0      		rjmp .L132
 1135               	.L62:
 482:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1136               		.loc 1 482 0
 1137 01bc 8C2F      		mov r24,r28
 1138 01be 8370      		andi r24,lo8(3)
 1139 01c0 01F0      		breq .+2
 1140 01c2 00C0      		rjmp .L101
 484:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1141               		.loc 1 484 0
 1142 01c4 D111      		cpse r29,__zero_reg__
 1143 01c6 00C0      		rjmp .L133
 1144               	.LVL125:
 1145               	.LBB124:
 485:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1146               		.loc 1 485 0
 1147 01c8 402F      		mov r20,r16
 1148 01ca 4295      		swap r20
 1149 01cc 4695      		lsr r20
 1150 01ce 4770      		andi r20,lo8(7)
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1151               		.loc 1 486 0
 1152 01d0 440F      		lsl r20
 1153 01d2 440F      		lsl r20
 1154 01d4 602F      		mov r22,r16
 1155 01d6 6F70      		andi r22,lo8(15)
 1156 01d8 862F      		mov r24,r22
 1157 01da 90E0      		ldi r25,0
 1158 01dc A0E0      		ldi r26,0
 1159 01de B0E0      		ldi r27,0
 1160 01e0 042E      		mov r0,r20
 1161 01e2 00C0      		rjmp 2f
 1162               		1:
 1163 01e4 880F      		lsl r24
 1164 01e6 991F      		rol r25
 1165 01e8 AA1F      		rol r26
 1166 01ea BB1F      		rol r27
 1167               		2:
 1168 01ec 0A94      		dec r0
 1169 01ee 02F4      		brpl 1b
 1170               	.LVL126:
 487:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1171               		.loc 1 487 0
 1172 01f0 04FF      		sbrs r16,4
 1173 01f2 00C0      		rjmp .L140
 487:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1174               		.loc 1 487 0 is_stmt 0 discriminator 1
 1175 01f4 0FE0      		ldi r16,lo8(15)
 1176 01f6 10E0      		ldi r17,0
 1177 01f8 20E0      		ldi r18,0
 1178 01fa 30E0      		ldi r19,0
 1179               	.LVL127:
 1180 01fc 00C0      		rjmp 2f
 1181               		1:
 1182 01fe 000F      		lsl r16
 1183 0200 111F      		rol r17
 1184 0202 221F      		rol r18
 1185 0204 331F      		rol r19
 1186               		2:
 1187 0206 4A95      		dec r20
 1188 0208 02F4      		brpl 1b
 1189 020a 0095      		com r16
 1190 020c 1095      		com r17
 1191 020e 2095      		com r18
 1192 0210 3095      		com r19
 1193 0212 00C0      		rjmp .L103
 1194               	.LVL128:
 1195               	.L140:
 487:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1196               		.loc 1 487 0
 1197 0214 00E0      		ldi r16,0
 1198 0216 10E0      		ldi r17,0
 1199 0218 9801      		movw r18,r16
 1200               	.LVL129:
 1201               	.L103:
 488:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1202               		.loc 1 488 0 is_stmt 1 discriminator 4
 1203 021a C695      		lsr r28
 1204 021c C695      		lsr r28
 1205 021e C370      		andi r28,lo8(3)
 1206 0220 BC01      		movw r22,r24
 1207 0222 CD01      		movw r24,r26
 1208 0224 602B      		or r22,r16
 1209 0226 712B      		or r23,r17
 1210 0228 822B      		or r24,r18
 1211 022a 932B      		or r25,r19
 1212 022c C230      		cpi r28,lo8(2)
 1213 022e 01F0      		breq .L105
 1214 0230 00F4      		brsh .L106
 1215 0232 C130      		cpi r28,lo8(1)
 1216 0234 01F0      		breq .L107
 490:tmk_core/common/action.c ****                             break;
 1217               		.loc 1 490 0 discriminator 4
 1218 0236 0E94 0000 		call default_layer_and
 1219               	.LVL130:
 491:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1220               		.loc 1 491 0 discriminator 4
 1221 023a 00C0      		rjmp .L133
 1222               	.LVL131:
 1223               	.L107:
 493:tmk_core/common/action.c ****                             break;
 1224               		.loc 1 493 0
 1225 023c 0E94 0000 		call default_layer_or
 1226               	.LVL132:
 494:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1227               		.loc 1 494 0
 1228 0240 00C0      		rjmp .L133
 1229               	.LVL133:
 1230               	.L105:
 496:tmk_core/common/action.c ****                             break;
 1231               		.loc 1 496 0
 1232 0242 0E94 0000 		call default_layer_xor
 1233               	.LVL134:
 497:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1234               		.loc 1 497 0
 1235 0246 00C0      		rjmp .L133
 1236               	.LVL135:
 1237               	.L106:
 499:tmk_core/common/action.c ****                             break;
 1238               		.loc 1 499 0
 1239 0248 0E94 0000 		call default_layer_set
 1240               	.LVL136:
 500:tmk_core/common/action.c ****                     }
 1241               		.loc 1 500 0
 1242 024c 00C0      		rjmp .L133
 1243               	.LVL137:
 1244               	.L101:
 1245               	.LBE124:
 505:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1246               		.loc 1 505 0
 1247 024e DD23      		tst r29
 1248 0250 01F0      		breq .L108
 505:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1249               		.loc 1 505 0 is_stmt 0 discriminator 1
 1250 0252 8C2F      		mov r24,r28
 1251 0254 8170      		andi r24,lo8(1)
 1252 0256 00C0      		rjmp .L109
 1253               	.L108:
 505:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1254               		.loc 1 505 0 discriminator 2
 1255 0258 8695      		lsr r24
 1256               	.L109:
 505:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1257               		.loc 1 505 0 discriminator 4
 1258 025a 8823      		tst r24
 1259 025c 01F4      		brne .+2
 1260 025e 00C0      		rjmp .L133
 1261               	.LVL138:
 1262               	.LBB125:
 506:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1263               		.loc 1 506 0 is_stmt 1
 1264 0260 402F      		mov r20,r16
 1265 0262 4295      		swap r20
 1266 0264 4695      		lsr r20
 1267 0266 4770      		andi r20,lo8(7)
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1268               		.loc 1 507 0
 1269 0268 440F      		lsl r20
 1270 026a 440F      		lsl r20
 1271 026c 602F      		mov r22,r16
 1272 026e 6F70      		andi r22,lo8(15)
 1273 0270 862F      		mov r24,r22
 1274 0272 90E0      		ldi r25,0
 1275 0274 A0E0      		ldi r26,0
 1276 0276 B0E0      		ldi r27,0
 1277 0278 042E      		mov r0,r20
 1278 027a 00C0      		rjmp 2f
 1279               		1:
 1280 027c 880F      		lsl r24
 1281 027e 991F      		rol r25
 1282 0280 AA1F      		rol r26
 1283 0282 BB1F      		rol r27
 1284               		2:
 1285 0284 0A94      		dec r0
 1286 0286 02F4      		brpl 1b
 1287               	.LVL139:
 508:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1288               		.loc 1 508 0
 1289 0288 04FF      		sbrs r16,4
 1290 028a 00C0      		rjmp .L141
 508:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1291               		.loc 1 508 0 is_stmt 0 discriminator 1
 1292 028c 0FE0      		ldi r16,lo8(15)
 1293 028e 10E0      		ldi r17,0
 1294 0290 20E0      		ldi r18,0
 1295 0292 30E0      		ldi r19,0
 1296               	.LVL140:
 1297 0294 00C0      		rjmp 2f
 1298               		1:
 1299 0296 000F      		lsl r16
 1300 0298 111F      		rol r17
 1301 029a 221F      		rol r18
 1302 029c 331F      		rol r19
 1303               		2:
 1304 029e 4A95      		dec r20
 1305 02a0 02F4      		brpl 1b
 1306 02a2 0095      		com r16
 1307 02a4 1095      		com r17
 1308 02a6 2095      		com r18
 1309 02a8 3095      		com r19
 1310 02aa 00C0      		rjmp .L110
 1311               	.LVL141:
 1312               	.L141:
 508:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1313               		.loc 1 508 0
 1314 02ac 00E0      		ldi r16,0
 1315 02ae 10E0      		ldi r17,0
 1316 02b0 9801      		movw r18,r16
 1317               	.LVL142:
 1318               	.L110:
 509:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1319               		.loc 1 509 0 is_stmt 1 discriminator 4
 1320 02b2 C695      		lsr r28
 1321 02b4 C695      		lsr r28
 1322 02b6 C370      		andi r28,lo8(3)
 1323 02b8 BC01      		movw r22,r24
 1324 02ba CD01      		movw r24,r26
 1325 02bc 602B      		or r22,r16
 1326 02be 712B      		or r23,r17
 1327 02c0 822B      		or r24,r18
 1328 02c2 932B      		or r25,r19
 1329 02c4 C230      		cpi r28,lo8(2)
 1330 02c6 01F0      		breq .L112
 1331 02c8 00F4      		brsh .L113
 1332 02ca C130      		cpi r28,lo8(1)
 1333 02cc 01F0      		breq .L114
 511:tmk_core/common/action.c ****                             break;
 1334               		.loc 1 511 0 discriminator 4
 1335 02ce 0E94 0000 		call layer_and
 1336               	.LVL143:
 512:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1337               		.loc 1 512 0 discriminator 4
 1338 02d2 00C0      		rjmp .L133
 1339               	.LVL144:
 1340               	.L114:
 514:tmk_core/common/action.c ****                             break;
 1341               		.loc 1 514 0
 1342 02d4 0E94 0000 		call layer_or
 1343               	.LVL145:
 515:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1344               		.loc 1 515 0
 1345 02d8 00C0      		rjmp .L133
 1346               	.LVL146:
 1347               	.L112:
 517:tmk_core/common/action.c ****                             break;
 1348               		.loc 1 517 0
 1349 02da 0E94 0000 		call layer_xor
 1350               	.LVL147:
 518:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1351               		.loc 1 518 0
 1352 02de 00C0      		rjmp .L133
 1353               	.LVL148:
 1354               	.L113:
 520:tmk_core/common/action.c ****                             break;
 1355               		.loc 1 520 0
 1356 02e0 0E94 0000 		call layer_state_set
 1357               	.LVL149:
 521:tmk_core/common/action.c ****                     }
 1358               		.loc 1 521 0
 1359 02e4 00C0      		rjmp .L133
 1360               	.LVL150:
 1361               	.L63:
 1362 02e6 CF70      		andi r28,lo8(15)
 1363               	.LVL151:
 1364               	.LBE125:
 527:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1365               		.loc 1 527 0
 1366 02e8 DD23      		tst r29
 1367 02ea 01F0      		breq .L115
 528:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1368               		.loc 1 528 0
 1369 02ec 8C2F      		mov r24,r28
 1370 02ee 0E94 0000 		call layer_on
 1371               	.LVL152:
 529:tmk_core/common/action.c ****             } else {
 1372               		.loc 1 529 0
 1373 02f2 802F      		mov r24,r16
 1374 02f4 0E94 0000 		call register_mods
 1375               	.LVL153:
 1376 02f8 00C0      		rjmp .L133
 1377               	.L115:
 531:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1378               		.loc 1 531 0
 1379 02fa 802F      		mov r24,r16
 1380 02fc 0E94 0000 		call unregister_mods
 1381               	.LVL154:
 532:tmk_core/common/action.c ****             }
 1382               		.loc 1 532 0
 1383 0300 8C2F      		mov r24,r28
 1384 0302 0E94 0000 		call layer_off
 1385               	.LVL155:
 1386 0306 00C0      		rjmp .L133
 1387               	.LVL156:
 1388               	.L64:
 538:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1389               		.loc 1 538 0
 1390 0308 023F      		cpi r16,lo8(-14)
 1391 030a 01F0      		breq .L117
 1392 030c 00F4      		brsh .L118
 1393 030e 003F      		cpi r16,lo8(-16)
 1394 0310 01F0      		breq .L119
 1395 0312 013F      		cpi r16,lo8(-15)
 1396 0314 01F0      		breq .L120
 1397 0316 00C0      		rjmp .L116
 1398               	.L118:
 1399 0318 033F      		cpi r16,lo8(-13)
 1400 031a 01F0      		breq .L121
 1401 031c 043F      		cpi r16,lo8(-12)
 1402 031e 01F0      		breq .L122
 1403 0320 00C0      		rjmp .L116
 1404               	.L119:
 541:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1405               		.loc 1 541 0
 1406 0322 DD23      		tst r29
 1407 0324 01F0      		breq .L123
 542:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1408               		.loc 1 542 0
 1409 0326 1530      		cpi r17,lo8(5)
 1410 0328 00F0      		brlo .+2
 1411 032a 00C0      		rjmp .L56
 1412               	.L124:
 543:tmk_core/common/action.c ****                         }
 1413               		.loc 1 543 0
 1414 032c 8C2F      		mov r24,r28
 1415 032e 8F71      		andi r24,lo8(31)
 1416 0330 0E94 0000 		call layer_invert
 1417               	.LVL157:
 1418 0334 00C0      		rjmp .L56
 1419               	.L123:
 546:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1420               		.loc 1 546 0
 1421 0336 1630      		cpi r17,lo8(6)
 1422 0338 00F0      		brlo .+2
 1423 033a 00C0      		rjmp .L56
 1424 033c 00C0      		rjmp .L124
 1425               	.L120:
 552:tmk_core/common/action.c ****                     break;
 1426               		.loc 1 552 0
 1427 033e DD23      		tst r29
 1428 0340 01F0      		breq .L125
 1429               	.L126:
 552:tmk_core/common/action.c ****                     break;
 1430               		.loc 1 552 0 is_stmt 0 discriminator 1
 1431 0342 8C2F      		mov r24,r28
 1432 0344 8F71      		andi r24,lo8(31)
 1433 0346 0E94 0000 		call layer_on
 1434               	.LVL158:
 1435 034a 00C0      		rjmp .L56
 1436               	.L117:
 555:tmk_core/common/action.c ****                     break;
 1437               		.loc 1 555 0 is_stmt 1
 1438 034c DD23      		tst r29
 1439 034e 01F0      		breq .L126
 1440               	.L125:
 552:tmk_core/common/action.c ****                     break;
 1441               		.loc 1 552 0 discriminator 2
 1442 0350 8C2F      		mov r24,r28
 1443 0352 8F71      		andi r24,lo8(31)
 1444 0354 0E94 0000 		call layer_off
 1445               	.LVL159:
 1446 0358 00C0      		rjmp .L56
 1447               	.L121:
 558:tmk_core/common/action.c ****                     break;
 1448               		.loc 1 558 0
 1449 035a DD23      		tst r29
 1450 035c 01F0      		breq .L127
 558:tmk_core/common/action.c ****                     break;
 1451               		.loc 1 558 0 is_stmt 0 discriminator 1
 1452 035e 8C2F      		mov r24,r28
 1453 0360 8F71      		andi r24,lo8(31)
 1454 0362 0E94 0000 		call layer_move
 1455               	.LVL160:
 1456 0366 00C0      		rjmp .L56
 1457               	.L127:
 558:tmk_core/common/action.c ****                     break;
 1458               		.loc 1 558 0 discriminator 2
 1459 0368 0E94 0000 		call layer_clear
 1460               	.LVL161:
 1461 036c 00C0      		rjmp .L56
 1462               	.L122:
 586:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1463               		.loc 1 586 0 is_stmt 1
 1464 036e DD23      		tst r29
 1465 0370 01F0      		breq .L128
 587:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1466               		.loc 1 587 0
 1467 0372 CF71      		andi r28,lo8(31)
 1468               	.LVL162:
 1469 0374 8C2F      		mov r24,r28
 1470 0376 0E94 0000 		call layer_on
 1471               	.LVL163:
 588:tmk_core/common/action.c ****                     } else {
 1472               		.loc 1 588 0
 1473 037a 63E0      		ldi r22,lo8(3)
 1474 037c 8C2F      		mov r24,r28
 1475 037e 0E94 0000 		call set_oneshot_layer
 1476               	.LVL164:
 1477 0382 00C0      		rjmp .L56
 1478               	.LVL165:
 1479               	.L128:
 590:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1480               		.loc 1 590 0
 1481 0384 81E0      		ldi r24,lo8(1)
 1482 0386 0E94 0000 		call clear_oneshot_layer_state
 1483               	.LVL166:
 591:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1484               		.loc 1 591 0
 1485 038a 1230      		cpi r17,lo8(2)
 1486 038c 00F0      		brlo .L56
 592:tmk_core/common/action.c ****                         }
 1487               		.loc 1 592 0
 1488 038e 82E0      		ldi r24,lo8(2)
 1489 0390 0E94 0000 		call clear_oneshot_layer_state
 1490               	.LVL167:
 1491 0394 00C0      		rjmp .L56
 1492               	.L116:
 600:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1493               		.loc 1 600 0
 1494 0396 DD23      		tst r29
 1495 0398 01F0      		breq .L129
 601:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1496               		.loc 1 601 0
 1497 039a 1123      		tst r17
 1498 039c 01F0      		breq .L126
 1499               	.L167:
 603:tmk_core/common/action.c ****                         } else {
 1500               		.loc 1 603 0
 1501 039e 802F      		mov r24,r16
 1502 03a0 0E94 0000 		call register_code
 1503               	.LVL168:
 1504 03a4 00C0      		rjmp .L56
 1505               	.L129:
 609:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1506               		.loc 1 609 0
 1507 03a6 1123      		tst r17
 1508 03a8 01F0      		breq .L125
 611:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1509               		.loc 1 611 0
 1510 03aa 0933      		cpi r16,lo8(57)
 1511 03ac 01F4      		brne .L131
 1512               	.LVL169:
 1513               	.LBB126:
 1514               	.LBB127:
 1515               		.loc 3 187 0
 1516 03ae 9FEF      		ldi r25,lo8(255999)
 1517 03b0 E7EE      		ldi r30,hi8(255999)
 1518 03b2 F3E0      		ldi r31,hlo8(255999)
 1519 03b4 9150      	1:	subi r25,1
 1520 03b6 E040      		sbci r30,0
 1521 03b8 F040      		sbci r31,0
 1522 03ba 01F4      		brne 1b
 1523               	.LVL170:
 1524               	.L174:
 1525 03bc 00C0      		rjmp .
 1526 03be 0000      		nop
 1527               	.L131:
 1528               	.LBE127:
 1529               	.LBE126:
 616:tmk_core/common/action.c ****                         } else {
 1530               		.loc 1 616 0
 1531 03c0 802F      		mov r24,r16
 1532 03c2 0E94 0000 		call unregister_code
 1533               	.LVL171:
 1534 03c6 00C0      		rjmp .L56
 1535               	.L65:
 630:tmk_core/common/action.c ****             break;
 1536               		.loc 1 630 0
 1537 03c8 4C2F      		mov r20,r28
 1538 03ca 4F70      		andi r20,lo8(15)
 1539 03cc 602F      		mov r22,r16
 1540 03ce C701      		movw r24,r14
 1541 03d0 0E94 0000 		call action_get_macro
 1542               	.LVL172:
 1543 03d4 0E94 0000 		call action_macro_play
 1544               	.LVL173:
 631:tmk_core/common/action.c **** #endif
 1545               		.loc 1 631 0
 1546 03d8 00C0      		rjmp .L132
 1547               	.L66:
 708:tmk_core/common/action.c ****             break;
 1548               		.loc 1 708 0
 1549 03da 4C2F      		mov r20,r28
 1550 03dc 4F70      		andi r20,lo8(15)
 1551 03de 602F      		mov r22,r16
 1552 03e0 C701      		movw r24,r14
 1553 03e2 0E94 0000 		call action_function
 1554               	.LVL174:
 709:tmk_core/common/action.c **** #endif
 1555               		.loc 1 709 0
 1556 03e6 00C0      		rjmp .L132
 1557               	.L56:
 717:tmk_core/common/action.c ****         case ACT_LAYER:
 1558               		.loc 1 717 0
 1559 03e8 88EF      		ldi r24,lo8(-8)
 1560 03ea 8C0D      		add r24,r12
 1561 03ec 8430      		cpi r24,lo8(4)
 1562 03ee 00F4      		brsh .L132
 1563               	.L133:
 724:tmk_core/common/action.c ****             break;
 1564               		.loc 1 724 0
 1565 03f0 0E94 0000 		call host_keyboard_leds
 1566               	.LVL175:
 1567 03f4 0E94 0000 		call led_set
 1568               	.LVL176:
 1569               	.L132:
 770:tmk_core/common/action.c ****         record->event.pressed = false;
 1570               		.loc 1 770 0
 1571 03f8 DD20      		tst r13
 1572 03fa 01F0      		breq .L52
 770:tmk_core/common/action.c ****         record->event.pressed = false;
 1573               		.loc 1 770 0 is_stmt 0 discriminator 1
 1574 03fc 0E94 0000 		call get_oneshot_layer_state
 1575               	.LVL177:
 1576 0400 80FD      		sbrc r24,0
 1577 0402 00C0      		rjmp .L52
 771:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1578               		.loc 1 771 0 is_stmt 1
 1579 0404 F701      		movw r30,r14
 1580 0406 1282      		std Z+2,__zero_reg__
 772:tmk_core/common/action.c ****         process_record(record);
 1581               		.loc 1 772 0
 1582 0408 0E94 0000 		call get_oneshot_layer
 1583               	.LVL178:
 1584 040c 0E94 0000 		call layer_on
 1585               	.LVL179:
 773:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1586               		.loc 1 773 0
 1587 0410 C701      		movw r24,r14
 1588 0412 0E94 0000 		call process_record
 1589               	.LVL180:
 774:tmk_core/common/action.c ****     }
 1590               		.loc 1 774 0
 1591 0416 0E94 0000 		call get_oneshot_layer
 1592               	.LVL181:
 1593               	/* epilogue start */
 777:tmk_core/common/action.c **** 
 1594               		.loc 1 777 0
 1595 041a DF91      		pop r29
 1596               	.LVL182:
 1597 041c CF91      		pop r28
 1598               	.LVL183:
 1599 041e 1F91      		pop r17
 1600               	.LVL184:
 1601 0420 0F91      		pop r16
 1602 0422 FF90      		pop r15
 1603 0424 EF90      		pop r14
 1604               	.LVL185:
 1605 0426 DF90      		pop r13
 1606               	.LVL186:
 1607 0428 CF90      		pop r12
 774:tmk_core/common/action.c ****     }
 1608               		.loc 1 774 0
 1609 042a 0C94 0000 		jmp layer_off
 1610               	.LVL187:
 1611               	.L52:
 1612               	/* epilogue start */
 777:tmk_core/common/action.c **** 
 1613               		.loc 1 777 0
 1614 042e DF91      		pop r29
 1615               	.LVL188:
 1616 0430 CF91      		pop r28
 1617               	.LVL189:
 1618 0432 1F91      		pop r17
 1619               	.LVL190:
 1620 0434 0F91      		pop r16
 1621 0436 FF90      		pop r15
 1622 0438 EF90      		pop r14
 1623               	.LVL191:
 1624 043a DF90      		pop r13
 1625               	.LVL192:
 1626 043c CF90      		pop r12
 1627 043e 0895      		ret
 1628               		.cfi_endproc
 1629               	.LFE115:
 1631               		.section	.text.process_record_handler,"ax",@progbits
 1632               	.global	process_record_handler
 1634               	process_record_handler:
 1635               	.LFB114:
 216:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1636               		.loc 1 216 0
 1637               		.cfi_startproc
 1638               	.LVL193:
 1639 0000 0F93      		push r16
 1640               	.LCFI14:
 1641               		.cfi_def_cfa_offset 3
 1642               		.cfi_offset 16, -2
 1643 0002 1F93      		push r17
 1644               	.LCFI15:
 1645               		.cfi_def_cfa_offset 4
 1646               		.cfi_offset 17, -3
 1647 0004 CF93      		push r28
 1648               	.LCFI16:
 1649               		.cfi_def_cfa_offset 5
 1650               		.cfi_offset 28, -4
 1651 0006 DF93      		push r29
 1652               	.LCFI17:
 1653               		.cfi_def_cfa_offset 6
 1654               		.cfi_offset 29, -5
 1655               	/* prologue: function */
 1656               	/* frame size = 0 */
 1657               	/* stack size = 4 */
 1658               	.L__stack_usage = 4
 1659 0008 EC01      		movw r28,r24
 217:tmk_core/common/action.c ****     dprint("ACTION: ");
 1660               		.loc 1 217 0
 1661 000a 6881      		ld r22,Y
 1662 000c 7981      		ldd r23,Y+1
 1663 000e 8A81      		ldd r24,Y+2
 1664               	.LVL194:
 1665 0010 0E94 0000 		call store_or_get_action
 1666               	.LVL195:
 1667 0014 8C01      		movw r16,r24
 1668               	.LVL196:
 222:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1669               		.loc 1 222 0
 1670 0016 0E94 0000 		call layer_debug
 1671               	.LVL197:
 224:tmk_core/common/action.c **** #endif
 1672               		.loc 1 224 0
 1673 001a 0E94 0000 		call default_layer_debug
 1674               	.LVL198:
 228:tmk_core/common/action.c **** }
 1675               		.loc 1 228 0
 1676 001e B801      		movw r22,r16
 1677 0020 CE01      		movw r24,r28
 1678 0022 0E94 0000 		call process_action
 1679               	.LVL199:
 1680               	/* epilogue start */
 229:tmk_core/common/action.c **** 
 1681               		.loc 1 229 0
 1682 0026 DF91      		pop r29
 1683 0028 CF91      		pop r28
 1684               	.LVL200:
 1685 002a 1F91      		pop r17
 1686 002c 0F91      		pop r16
 1687               	.LVL201:
 1688 002e 0895      		ret
 1689               		.cfi_endproc
 1690               	.LFE114:
 1692               		.section	.text.process_record,"ax",@progbits
 1693               	.global	process_record
 1695               	process_record:
 1696               	.LFB113:
 198:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1697               		.loc 1 198 0
 1698               		.cfi_startproc
 1699               	.LVL202:
 1700 0000 CF93      		push r28
 1701               	.LCFI18:
 1702               		.cfi_def_cfa_offset 3
 1703               		.cfi_offset 28, -2
 1704 0002 DF93      		push r29
 1705               	.LCFI19:
 1706               		.cfi_def_cfa_offset 4
 1707               		.cfi_offset 29, -3
 1708               	/* prologue: function */
 1709               	/* frame size = 0 */
 1710               	/* stack size = 2 */
 1711               	.L__stack_usage = 2
 1712 0004 EC01      		movw r28,r24
 1713 0006 9881      		ld r25,Y
 1714 0008 8981      		ldd r24,Y+1
 1715               	.LVL203:
 1716               	.LBB130:
 1717               	.LBB131:
 1718               		.file 4 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1719               		.loc 4 48 0
 1720 000a 2B81      		ldd r18,Y+3
 1721 000c 3C81      		ldd r19,Y+4
 1722 000e 232B      		or r18,r19
 1723 0010 01F0      		breq .L184
 1724 0012 8F3F      		cpi r24,lo8(-1)
 1725 0014 01F4      		brne .L185
 1726 0016 81E0      		ldi r24,lo8(1)
 1727 0018 9F3F      		cpi r25,lo8(-1)
 1728 001a 01F4      		brne .L185
 1729 001c 00C0      		rjmp .L178
 1730               	.L184:
 1731 001e 81E0      		ldi r24,lo8(1)
 1732 0020 00C0      		rjmp .L178
 1733               	.L185:
 1734 0022 80E0      		ldi r24,0
 1735               	.L178:
 1736               	.LBE131:
 1737               	.LBE130:
 199:tmk_core/common/action.c ****         return;
 1738               		.loc 1 199 0
 1739 0024 80FD      		sbrc r24,0
 1740 0026 00C0      		rjmp .L177
 203:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1741               		.loc 1 203 0
 1742 0028 CE01      		movw r24,r28
 1743 002a 0E94 0000 		call process_record_quantum
 1744               	.LVL204:
 1745 002e 8111      		cpse r24,__zero_reg__
 1746 0030 00C0      		rjmp .L182
 205:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1747               		.loc 1 205 0
 1748 0032 0E94 0000 		call is_oneshot_layer_active
 1749               	.LVL205:
 1750 0036 8823      		tst r24
 1751 0038 01F0      		breq .L177
 205:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1752               		.loc 1 205 0 is_stmt 0 discriminator 1
 1753 003a 8A81      		ldd r24,Y+2
 1754 003c 8823      		tst r24
 1755 003e 01F0      		breq .L177
 206:tmk_core/common/action.c ****         }
 1756               		.loc 1 206 0 is_stmt 1
 1757 0040 82E0      		ldi r24,lo8(2)
 1758               	/* epilogue start */
 214:tmk_core/common/action.c **** 
 1759               		.loc 1 214 0
 1760 0042 DF91      		pop r29
 1761 0044 CF91      		pop r28
 1762               	.LVL206:
 206:tmk_core/common/action.c ****         }
 1763               		.loc 1 206 0
 1764 0046 0C94 0000 		jmp clear_oneshot_layer_state
 1765               	.LVL207:
 1766               	.L182:
 212:tmk_core/common/action.c ****     post_process_record_quantum(record);
 1767               		.loc 1 212 0
 1768 004a CE01      		movw r24,r28
 1769 004c 0E94 0000 		call process_record_handler
 1770               	.LVL208:
 213:tmk_core/common/action.c **** }
 1771               		.loc 1 213 0
 1772 0050 CE01      		movw r24,r28
 1773               	/* epilogue start */
 214:tmk_core/common/action.c **** 
 1774               		.loc 1 214 0
 1775 0052 DF91      		pop r29
 1776 0054 CF91      		pop r28
 1777               	.LVL209:
 213:tmk_core/common/action.c **** }
 1778               		.loc 1 213 0
 1779 0056 0C94 0000 		jmp post_process_record_quantum
 1780               	.LVL210:
 1781               	.L177:
 1782               	/* epilogue start */
 214:tmk_core/common/action.c **** 
 1783               		.loc 1 214 0
 1784 005a DF91      		pop r29
 1785 005c CF91      		pop r28
 1786               	.LVL211:
 1787 005e 0895      		ret
 1788               		.cfi_endproc
 1789               	.LFE113:
 1791               		.section	.text.process_record_nocache,"ax",@progbits
 1792               	.global	process_record_nocache
 1794               	process_record_nocache:
 1795               	.LFB109:
 156:tmk_core/common/action.c ****     disable_action_cache = true;
 1796               		.loc 1 156 0
 1797               		.cfi_startproc
 1798               	.LVL212:
 1799               	/* prologue: function */
 1800               	/* frame size = 0 */
 1801               	/* stack size = 0 */
 1802               	.L__stack_usage = 0
 157:tmk_core/common/action.c ****     process_record(record);
 1803               		.loc 1 157 0
 1804 0000 21E0      		ldi r18,lo8(1)
 1805 0002 2093 0000 		sts disable_action_cache,r18
 158:tmk_core/common/action.c ****     disable_action_cache = false;
 1806               		.loc 1 158 0
 1807 0006 0E94 0000 		call process_record
 1808               	.LVL213:
 159:tmk_core/common/action.c **** }
 1809               		.loc 1 159 0
 1810 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 1811 000e 0895      		ret
 1812               		.cfi_endproc
 1813               	.LFE109:
 1815               		.section	.text.register_weak_mods,"ax",@progbits
 1816               	.global	register_weak_mods
 1818               	register_weak_mods:
 1819               	.LFB121:
 972:tmk_core/common/action.c ****     }
 973:tmk_core/common/action.c **** }
 974:tmk_core/common/action.c **** 
 975:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 976:tmk_core/common/action.c ****  *
 977:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 978:tmk_core/common/action.c ****  */
 979:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 1820               		.loc 1 979 0
 1821               		.cfi_startproc
 1822               	.LVL214:
 1823               	/* prologue: function */
 1824               	/* frame size = 0 */
 1825               	/* stack size = 0 */
 1826               	.L__stack_usage = 0
 980:tmk_core/common/action.c ****     if (mods) {
 1827               		.loc 1 980 0
 1828 0000 8823      		tst r24
 1829 0002 01F0      		breq .L196
 981:tmk_core/common/action.c ****         add_weak_mods(mods);
 1830               		.loc 1 981 0
 1831 0004 0E94 0000 		call add_weak_mods
 1832               	.LVL215:
 982:tmk_core/common/action.c ****         send_keyboard_report();
 1833               		.loc 1 982 0
 1834 0008 0C94 0000 		jmp send_keyboard_report
 1835               	.LVL216:
 1836               	.L196:
 1837 000c 0895      		ret
 1838               		.cfi_endproc
 1839               	.LFE121:
 1841               		.section	.text.unregister_weak_mods,"ax",@progbits
 1842               	.global	unregister_weak_mods
 1844               	unregister_weak_mods:
 1845               	.LFB122:
 983:tmk_core/common/action.c ****     }
 984:tmk_core/common/action.c **** }
 985:tmk_core/common/action.c **** 
 986:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 987:tmk_core/common/action.c ****  *
 988:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 989:tmk_core/common/action.c ****  */
 990:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 1846               		.loc 1 990 0
 1847               		.cfi_startproc
 1848               	.LVL217:
 1849               	/* prologue: function */
 1850               	/* frame size = 0 */
 1851               	/* stack size = 0 */
 1852               	.L__stack_usage = 0
 991:tmk_core/common/action.c ****     if (mods) {
 1853               		.loc 1 991 0
 1854 0000 8823      		tst r24
 1855 0002 01F0      		breq .L198
 992:tmk_core/common/action.c ****         del_weak_mods(mods);
 1856               		.loc 1 992 0
 1857 0004 0E94 0000 		call del_weak_mods
 1858               	.LVL218:
 993:tmk_core/common/action.c ****         send_keyboard_report();
 1859               		.loc 1 993 0
 1860 0008 0C94 0000 		jmp send_keyboard_report
 1861               	.LVL219:
 1862               	.L198:
 1863 000c 0895      		ret
 1864               		.cfi_endproc
 1865               	.LFE122:
 1867               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 1868               	.global	clear_keyboard_but_mods_and_keys
 1870               	clear_keyboard_but_mods_and_keys:
 1871               	.LFB125:
 994:tmk_core/common/action.c ****     }
 995:tmk_core/common/action.c **** }
 996:tmk_core/common/action.c **** 
 997:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 998:tmk_core/common/action.c ****  *
 999:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1000:tmk_core/common/action.c ****  */
1001:tmk_core/common/action.c **** void clear_keyboard(void) {
1002:tmk_core/common/action.c ****     clear_mods();
1003:tmk_core/common/action.c ****     clear_keyboard_but_mods();
1004:tmk_core/common/action.c **** }
1005:tmk_core/common/action.c **** 
1006:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1007:tmk_core/common/action.c ****  *
1008:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1009:tmk_core/common/action.c ****  */
1010:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
1011:tmk_core/common/action.c ****     clear_keys();
1012:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
1013:tmk_core/common/action.c **** }
1014:tmk_core/common/action.c **** 
1015:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1016:tmk_core/common/action.c ****  *
1017:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1018:tmk_core/common/action.c ****  */
1019:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 1872               		.loc 1 1019 0
 1873               		.cfi_startproc
 1874               	/* prologue: function */
 1875               	/* frame size = 0 */
 1876               	/* stack size = 0 */
 1877               	.L__stack_usage = 0
1020:tmk_core/common/action.c ****     clear_weak_mods();
 1878               		.loc 1 1020 0
 1879 0000 0E94 0000 		call clear_weak_mods
 1880               	.LVL220:
1021:tmk_core/common/action.c ****     clear_macro_mods();
 1881               		.loc 1 1021 0
 1882 0004 0E94 0000 		call clear_macro_mods
 1883               	.LVL221:
1022:tmk_core/common/action.c ****     send_keyboard_report();
 1884               		.loc 1 1022 0
 1885 0008 0E94 0000 		call send_keyboard_report
 1886               	.LVL222:
1023:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
1024:tmk_core/common/action.c ****     mousekey_clear();
 1887               		.loc 1 1024 0
 1888 000c 0E94 0000 		call mousekey_clear
 1889               	.LVL223:
1025:tmk_core/common/action.c ****     mousekey_send();
 1890               		.loc 1 1025 0
 1891 0010 0E94 0000 		call mousekey_send
 1892               	.LVL224:
1026:tmk_core/common/action.c **** #endif
1027:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
1028:tmk_core/common/action.c ****     host_system_send(0);
 1893               		.loc 1 1028 0
 1894 0014 80E0      		ldi r24,0
 1895 0016 90E0      		ldi r25,0
 1896 0018 0E94 0000 		call host_system_send
 1897               	.LVL225:
1029:tmk_core/common/action.c ****     host_consumer_send(0);
 1898               		.loc 1 1029 0
 1899 001c 80E0      		ldi r24,0
 1900 001e 90E0      		ldi r25,0
 1901 0020 0C94 0000 		jmp host_consumer_send
 1902               	.LVL226:
 1903               		.cfi_endproc
 1904               	.LFE125:
 1906               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1907               	.global	clear_keyboard_but_mods
 1909               	clear_keyboard_but_mods:
 1910               	.LFB124:
1010:tmk_core/common/action.c ****     clear_keys();
 1911               		.loc 1 1010 0
 1912               		.cfi_startproc
 1913               	/* prologue: function */
 1914               	/* frame size = 0 */
 1915               	/* stack size = 0 */
 1916               	.L__stack_usage = 0
 1917               	.LBB132:
 1918               	.LBB133:
  35:tmk_core/common/action_util.h **** 
  36:tmk_core/common/action_util.h **** inline void clear_keys(void) { clear_keys_from_report(keyboard_report); }
 1919               		.loc 2 36 0
 1920 0000 8091 0000 		lds r24,keyboard_report
 1921 0004 9091 0000 		lds r25,keyboard_report+1
 1922 0008 0E94 0000 		call clear_keys_from_report
 1923               	.LVL227:
 1924               	.LBE133:
 1925               	.LBE132:
1012:tmk_core/common/action.c **** }
 1926               		.loc 1 1012 0
 1927 000c 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 1928               	.LVL228:
 1929               		.cfi_endproc
 1930               	.LFE124:
 1932               		.section	.text.clear_keyboard,"ax",@progbits
 1933               	.global	clear_keyboard
 1935               	clear_keyboard:
 1936               	.LFB123:
1001:tmk_core/common/action.c ****     clear_mods();
 1937               		.loc 1 1001 0
 1938               		.cfi_startproc
 1939               	/* prologue: function */
 1940               	/* frame size = 0 */
 1941               	/* stack size = 0 */
 1942               	.L__stack_usage = 0
1002:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1943               		.loc 1 1002 0
 1944 0000 0E94 0000 		call clear_mods
 1945               	.LVL229:
1003:tmk_core/common/action.c **** }
 1946               		.loc 1 1003 0
 1947 0004 0C94 0000 		jmp clear_keyboard_but_mods
 1948               	.LVL230:
 1949               		.cfi_endproc
 1950               	.LFE123:
 1952               		.section	.text.is_tap_action,"ax",@progbits
 1953               	.global	is_tap_action
 1955               	is_tap_action:
 1956               	.LFB127:
1030:tmk_core/common/action.c **** #endif
1031:tmk_core/common/action.c **** }
1032:tmk_core/common/action.c **** 
1033:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1034:tmk_core/common/action.c ****  *
1035:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1036:tmk_core/common/action.c ****  */
1037:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
1038:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
1039:tmk_core/common/action.c ****     return is_tap_action(action);
1040:tmk_core/common/action.c **** }
1041:tmk_core/common/action.c **** 
1042:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1043:tmk_core/common/action.c ****  *
1044:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1045:tmk_core/common/action.c ****  */
1046:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 1957               		.loc 1 1046 0
 1958               		.cfi_startproc
 1959               	.LVL231:
 1960               	/* prologue: function */
 1961               	/* frame size = 0 */
 1962               	/* stack size = 0 */
 1963               	.L__stack_usage = 0
1047:tmk_core/common/action.c ****     switch (action.kind.id) {
 1964               		.loc 1 1047 0
 1965 0000 E92F      		mov r30,r25
 1966 0002 E295      		swap r30
 1967 0004 EF70      		andi r30,lo8(15)
 1968 0006 4E2F      		mov r20,r30
 1969 0008 50E0      		ldi r21,0
 1970 000a FA01      		movw r30,r20
 1971 000c 3297      		sbiw r30,2
 1972 000e EE30      		cpi r30,14
 1973 0010 F105      		cpc r31,__zero_reg__
 1974 0012 00F4      		brsh .L212
 1975 0014 E050      		subi r30,lo8(-(gs(.L206)))
 1976 0016 F040      		sbci r31,hi8(-(gs(.L206)))
 1977 0018 0C94 0000 		jmp __tablejump2__
 1978               		.section	.progmem.gcc_sw_table.is_tap_action,"a",@progbits
 1979               		.p2align	1
 1980               	.L206:
 1981 0000 0000      		.word gs(.L205)
 1982 0002 0000      		.word gs(.L205)
 1983 0004 0000      		.word gs(.L212)
 1984 0006 0000      		.word gs(.L212)
 1985 0008 0000      		.word gs(.L207)
 1986 000a 0000      		.word gs(.L212)
 1987 000c 0000      		.word gs(.L212)
 1988 000e 0000      		.word gs(.L212)
 1989 0010 0000      		.word gs(.L205)
 1990 0012 0000      		.word gs(.L205)
 1991 0014 0000      		.word gs(.L208)
 1992 0016 0000      		.word gs(.L212)
 1993 0018 0000      		.word gs(.L212)
 1994 001a 0000      		.word gs(.L208)
 1995               		.section	.text.is_tap_action
 1996               	.L205:
1048:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1049:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1050:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1051:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1052:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1997               		.loc 1 1052 0
 1998 001c 803F      		cpi r24,lo8(-16)
 1999 001e 01F0      		breq .L214
 2000 0020 00F4      		brsh .L210
 2001 0022 883E      		cpi r24,lo8(-24)
 2002 0024 00F4      		brsh .L212
 2003 0026 00C0      		rjmp .L214
 2004               	.L210:
 2005 0028 843F      		cpi r24,lo8(-12)
 2006 002a 01F4      		brne .L212
 2007 002c 00C0      		rjmp .L214
 2008               	.L207:
1053:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1054:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
1055:tmk_core/common/action.c ****                 case OP_ONESHOT:
1056:tmk_core/common/action.c ****                     return true;
1057:tmk_core/common/action.c ****             }
1058:tmk_core/common/action.c ****             return false;
1059:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1060:tmk_core/common/action.c ****             switch (action.swap.code) {
 2009               		.loc 1 1060 0
 2010 002e 883E      		cpi r24,lo8(-24)
 2011 0030 00F0      		brlo .L214
 2012 0032 813F      		cpi r24,lo8(-15)
 2013 0034 01F4      		brne .L212
 2014 0036 00C0      		rjmp .L214
 2015               	.L208:
1061:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1062:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
1063:tmk_core/common/action.c ****                     return true;
1064:tmk_core/common/action.c ****             }
1065:tmk_core/common/action.c ****             return false;
1066:tmk_core/common/action.c ****         case ACT_MACRO:
1067:tmk_core/common/action.c ****         case ACT_FUNCTION:
1068:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
 2016               		.loc 1 1068 0
 2017 0038 93FB      		bst r25,3
 2018 003a 8827      		clr r24
 2019 003c 80F9      		bld r24,0
 2020               	.LVL232:
 2021 003e 0895      		ret
 2022               	.LVL233:
 2023               	.L212:
1069:tmk_core/common/action.c ****                 return true;
1070:tmk_core/common/action.c ****             }
1071:tmk_core/common/action.c ****             return false;
1072:tmk_core/common/action.c ****     }
1073:tmk_core/common/action.c ****     return false;
 2024               		.loc 1 1073 0
 2025 0040 80E0      		ldi r24,0
 2026               	.LVL234:
 2027 0042 0895      		ret
 2028               	.LVL235:
 2029               	.L214:
1063:tmk_core/common/action.c ****             }
 2030               		.loc 1 1063 0
 2031 0044 81E0      		ldi r24,lo8(1)
 2032               	.LVL236:
1074:tmk_core/common/action.c **** }
 2033               		.loc 1 1074 0
 2034 0046 0895      		ret
 2035               		.cfi_endproc
 2036               	.LFE127:
 2038               		.section	.text.is_tap_key,"ax",@progbits
 2039               	.global	is_tap_key
 2041               	is_tap_key:
 2042               	.LFB126:
1037:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2043               		.loc 1 1037 0
 2044               		.cfi_startproc
 2045               	.LVL237:
 2046               	/* prologue: function */
 2047               	/* frame size = 0 */
 2048               	/* stack size = 0 */
 2049               	.L__stack_usage = 0
1038:tmk_core/common/action.c ****     return is_tap_action(action);
 2050               		.loc 1 1038 0
 2051 0000 0E94 0000 		call layer_switch_get_action
 2052               	.LVL238:
1039:tmk_core/common/action.c **** }
 2053               		.loc 1 1039 0
 2054 0004 0E94 0000 		call is_tap_action
 2055               	.LVL239:
1040:tmk_core/common/action.c **** 
 2056               		.loc 1 1040 0
 2057 0008 0895      		ret
 2058               		.cfi_endproc
 2059               	.LFE126:
 2061               		.section	.text.debug_event,"ax",@progbits
 2062               	.global	debug_event
 2064               	debug_event:
 2065               	.LFB128:
1075:tmk_core/common/action.c **** 
1076:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1077:tmk_core/common/action.c ****  *
1078:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1079:tmk_core/common/action.c ****  */
1080:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2066               		.loc 1 1080 0
 2067               		.cfi_startproc
 2068 0000 CF93      		push r28
 2069               	.LCFI20:
 2070               		.cfi_def_cfa_offset 3
 2071               		.cfi_offset 28, -2
 2072 0002 DF93      		push r29
 2073               	.LCFI21:
 2074               		.cfi_def_cfa_offset 4
 2075               		.cfi_offset 29, -3
 2076 0004 00D0      		rcall .
 2077 0006 00D0      		rcall .
 2078 0008 1F92      		push __zero_reg__
 2079               	.LCFI22:
 2080               		.cfi_def_cfa_offset 9
 2081 000a CDB7      		in r28,__SP_L__
 2082 000c DEB7      		in r29,__SP_H__
 2083               	.LCFI23:
 2084               		.cfi_def_cfa_register 28
 2085               	/* prologue: function */
 2086               	/* frame size = 5 */
 2087               	/* stack size = 7 */
 2088               	.L__stack_usage = 7
 2089               	/* epilogue start */
 2090               		.loc 1 1080 0
 2091 000e 0F90      		pop __tmp_reg__
 2092 0010 0F90      		pop __tmp_reg__
 2093 0012 0F90      		pop __tmp_reg__
 2094 0014 0F90      		pop __tmp_reg__
 2095 0016 0F90      		pop __tmp_reg__
 2096 0018 DF91      		pop r29
 2097 001a CF91      		pop r28
 2098 001c 0895      		ret
 2099               		.cfi_endproc
 2100               	.LFE128:
 2102               		.section	.text.debug_record,"ax",@progbits
 2103               	.global	debug_record
 2105               	debug_record:
 2106               	.LFB129:
1081:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1082:tmk_core/common/action.c ****  *
1083:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1084:tmk_core/common/action.c ****  */
1085:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 2107               		.loc 1 1085 0
 2108               		.cfi_startproc
 2109 0000 CF93      		push r28
 2110               	.LCFI24:
 2111               		.cfi_def_cfa_offset 3
 2112               		.cfi_offset 28, -2
 2113 0002 DF93      		push r29
 2114               	.LCFI25:
 2115               		.cfi_def_cfa_offset 4
 2116               		.cfi_offset 29, -3
 2117 0004 00D0      		rcall .
 2118 0006 00D0      		rcall .
 2119 0008 00D0      		rcall .
 2120               	.LCFI26:
 2121               		.cfi_def_cfa_offset 10
 2122 000a CDB7      		in r28,__SP_L__
 2123 000c DEB7      		in r29,__SP_H__
 2124               	.LCFI27:
 2125               		.cfi_def_cfa_register 28
 2126               	/* prologue: function */
 2127               	/* frame size = 6 */
 2128               	/* stack size = 8 */
 2129               	.L__stack_usage = 8
 2130               	/* epilogue start */
1086:tmk_core/common/action.c ****     debug_event(record.event);
1087:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1088:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
1089:tmk_core/common/action.c **** #endif
1090:tmk_core/common/action.c **** }
 2131               		.loc 1 1090 0
 2132 000e 2696      		adiw r28,6
 2133 0010 0FB6      		in __tmp_reg__,__SREG__
 2134 0012 F894      		cli
 2135 0014 DEBF      		out __SP_H__,r29
 2136 0016 0FBE      		out __SREG__,__tmp_reg__
 2137 0018 CDBF      		out __SP_L__,r28
 2138 001a DF91      		pop r29
 2139 001c CF91      		pop r28
 2140 001e 0895      		ret
 2141               		.cfi_endproc
 2142               	.LFE129:
 2144               		.section	.text.debug_action,"ax",@progbits
 2145               	.global	debug_action
 2147               	debug_action:
 2148               	.LFB130:
1091:tmk_core/common/action.c **** 
1092:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1093:tmk_core/common/action.c ****  *
1094:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1095:tmk_core/common/action.c ****  */
1096:tmk_core/common/action.c **** void debug_action(action_t action) {
 2149               		.loc 1 1096 0
 2150               		.cfi_startproc
 2151               	.LVL240:
 2152               	/* prologue: function */
 2153               	/* frame size = 0 */
 2154               	/* stack size = 0 */
 2155               	.L__stack_usage = 0
 2156 0000 0895      		ret
 2157               		.cfi_endproc
 2158               	.LFE130:
 2160               		.section	.rodata.CSWTCH.14,"a",@progbits
 2163               	CSWTCH.14:
 2164 0000 E200      		.word	226
 2165 0002 E900      		.word	233
 2166 0004 EA00      		.word	234
 2167 0006 B500      		.word	181
 2168 0008 B600      		.word	182
 2169 000a B700      		.word	183
 2170 000c CD00      		.word	205
 2171 000e 8301      		.word	387
 2172 0010 CC00      		.word	204
 2173 0012 8A01      		.word	394
 2174 0014 9201      		.word	402
 2175 0016 9401      		.word	404
 2176 0018 2102      		.word	545
 2177 001a 2302      		.word	547
 2178 001c 2402      		.word	548
 2179 001e 2502      		.word	549
 2180 0020 2602      		.word	550
 2181 0022 2702      		.word	551
 2182 0024 2A02      		.word	554
 2183 0026 B300      		.word	179
 2184 0028 B400      		.word	180
 2185 002a 6F00      		.word	111
 2186 002c 7000      		.word	112
 2187               		.section	.rodata.CSWTCH.12,"a",@progbits
 2190               	CSWTCH.12:
 2191 0000 81        		.byte	-127
 2192 0001 82        		.byte	-126
 2193 0002 83        		.byte	-125
 2194               	.global	disable_action_cache
 2195               		.section	.bss.disable_action_cache,"aw",@nobits
 2198               	disable_action_cache:
 2199 0000 00        		.zero	1
 2200               		.comm	tp_buttons,2,1
 2201               		.text
 2202               	.Letext0:
 2203               		.file 5 "/usr/lib/avr/include/stdint.h"
 2204               		.file 6 "tmk_core/common/keycode.h"
 2205               		.file 7 "tmk_core/common/report.h"
 2206               		.file 8 "tmk_core/common/action_code.h"
 2207               		.file 9 "tmk_core/common/action.h"
 2208               		.file 10 "tmk_core/common/action_layer.h"
 2209               		.file 11 "lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 2210               		.file 12 "tmk_core/common/action_tapping.h"
 2211               		.file 13 "tmk_core/common/host.h"
 2212               		.file 14 "tmk_core/common/mousekey.h"
 2213               		.file 15 "tmk_core/common/action_macro.h"
 2214               		.file 16 "tmk_core/common/led.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
     /tmp/ccVl6vhr.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccVl6vhr.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccVl6vhr.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccVl6vhr.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccVl6vhr.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccVl6vhr.s:13     .text.action_exec:0000000000000000 action_exec
     /tmp/ccVl6vhr.s:93     .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccVl6vhr.s:112    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
     /tmp/ccVl6vhr.s:128    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
     /tmp/ccVl6vhr.s:151    .text.register_code:0000000000000000 register_code
     /tmp/ccVl6vhr.s:2190   .rodata.CSWTCH.12:0000000000000000 CSWTCH.12
     /tmp/ccVl6vhr.s:2163   .rodata.CSWTCH.14:0000000000000000 CSWTCH.14
     /tmp/ccVl6vhr.s:444    .text.unregister_code:0000000000000000 unregister_code
     /tmp/ccVl6vhr.s:635    .text.tap_code:0000000000000000 tap_code
     /tmp/ccVl6vhr.s:687    .text.register_mods:0000000000000000 register_mods
     /tmp/ccVl6vhr.s:713    .text.unregister_mods:0000000000000000 unregister_mods
     /tmp/ccVl6vhr.s:739    .text.process_action:0000000000000000 process_action
     /tmp/ccVl6vhr.s:1695   .text.process_record:0000000000000000 process_record
     /tmp/ccVl6vhr.s:1634   .text.process_record_handler:0000000000000000 process_record_handler
     /tmp/ccVl6vhr.s:1794   .text.process_record_nocache:0000000000000000 process_record_nocache
     /tmp/ccVl6vhr.s:2198   .bss.disable_action_cache:0000000000000000 disable_action_cache
     /tmp/ccVl6vhr.s:1818   .text.register_weak_mods:0000000000000000 register_weak_mods
     /tmp/ccVl6vhr.s:1844   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
     /tmp/ccVl6vhr.s:1870   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
     /tmp/ccVl6vhr.s:1909   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
     /tmp/ccVl6vhr.s:1935   .text.clear_keyboard:0000000000000000 clear_keyboard
     /tmp/ccVl6vhr.s:1955   .text.is_tap_action:0000000000000000 is_tap_action
     /tmp/ccVl6vhr.s:2041   .text.is_tap_key:0000000000000000 is_tap_key
     /tmp/ccVl6vhr.s:2064   .text.debug_event:0000000000000000 debug_event
     /tmp/ccVl6vhr.s:2105   .text.debug_record:0000000000000000 debug_record
     /tmp/ccVl6vhr.s:2147   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
host_keyboard_leds
keyboard_report
add_key_to_report
send_keyboard_report
del_key_from_report
is_key_pressed
add_mods
host_system_send
host_consumer_send
mousekey_on
mousekey_send
del_mods
mousekey_off
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
layer_on
layer_off
layer_invert
layer_move
layer_clear
set_oneshot_layer
action_get_macro
action_macro_play
action_function
led_set
get_oneshot_layer_state
get_oneshot_layer
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
mousekey_clear
clear_keys_from_report
clear_mods
__do_copy_data
__do_clear_bss
